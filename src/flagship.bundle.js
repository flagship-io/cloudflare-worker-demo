!function (t, e) { if ("object" == typeof exports && "object" == typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { var i = e(); for (var s in i) ("object" == typeof exports ? exports : t)[s] = i[s] } }(self, (function () { return (() => { "use strict"; var t = { 187: t => { var e, i = "object" == typeof Reflect ? Reflect : null, s = i && "function" == typeof i.apply ? i.apply : function (t, e, i) { return Function.prototype.apply.call(t, e, i) }; e = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function (t) { return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t)) } : function (t) { return Object.getOwnPropertyNames(t) }; var n = Number.isNaN || function (t) { return t != t }; function a() { a.init.call(this) } t.exports = a, t.exports.once = function (t, e) { return new Promise((function (i, s) { function n(i) { t.removeListener(e, a), s(i) } function a() { "function" == typeof t.removeListener && t.removeListener("error", n), i([].slice.call(arguments)) } f(t, e, a, { once: !0 }), "error" !== e && function (t, e, i) { "function" == typeof t.on && f(t, "error", e, { once: !0 }) }(t, n) })) }, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0; var o = 10; function r(t) { if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t) } function c(t) { return void 0 === t._maxListeners ? a.defaultMaxListeners : t._maxListeners } function h(t, e, i, s) { var n, a, o, h; if (r(i), void 0 === (a = t._events) ? (a = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== a.newListener && (t.emit("newListener", e, i.listener ? i.listener : i), a = t._events), o = a[e]), void 0 === o) o = a[e] = i, ++t._eventsCount; else if ("function" == typeof o ? o = a[e] = s ? [i, o] : [o, i] : s ? o.unshift(i) : o.push(i), (n = c(t)) > 0 && o.length > n && !o.warned) { o.warned = !0; var g = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit"); g.name = "MaxListenersExceededWarning", g.emitter = t, g.type = e, g.count = o.length, h = g, console && console.warn && console.warn(h) } return t } function g() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function u(t, e, i) { var s = { fired: !1, wrapFn: void 0, target: t, type: e, listener: i }, n = g.bind(s); return n.listener = i, s.wrapFn = n, n } function d(t, e, i) { var s = t._events; if (void 0 === s) return []; var n = s[e]; return void 0 === n ? [] : "function" == typeof n ? i ? [n.listener || n] : [n] : i ? function (t) { for (var e = new Array(t.length), i = 0; i < e.length; ++i)e[i] = t[i].listener || t[i]; return e }(n) : p(n, n.length) } function l(t) { var e = this._events; if (void 0 !== e) { var i = e[t]; if ("function" == typeof i) return 1; if (void 0 !== i) return i.length } return 0 } function p(t, e) { for (var i = new Array(e), s = 0; s < e; ++s)i[s] = t[s]; return i } function f(t, e, i, s) { if ("function" == typeof t.on) s.once ? t.once(e, i) : t.on(e, i); else { if ("function" != typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t); t.addEventListener(e, (function n(a) { s.once && t.removeEventListener(e, n), i(a) })) } } Object.defineProperty(a, "defaultMaxListeners", { enumerable: !0, get: function () { return o }, set: function (t) { if ("number" != typeof t || t < 0 || n(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + "."); o = t } }), a.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, a.prototype.setMaxListeners = function (t) { if ("number" != typeof t || t < 0 || n(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + "."); return this._maxListeners = t, this }, a.prototype.getMaxListeners = function () { return c(this) }, a.prototype.emit = function (t) { for (var e = [], i = 1; i < arguments.length; i++)e.push(arguments[i]); var n = "error" === t, a = this._events; if (void 0 !== a) n = n && void 0 === a.error; else if (!n) return !1; if (n) { var o; if (e.length > 0 && (o = e[0]), o instanceof Error) throw o; var r = new Error("Unhandled error." + (o ? " (" + o.message + ")" : "")); throw r.context = o, r } var c = a[t]; if (void 0 === c) return !1; if ("function" == typeof c) s(c, this, e); else { var h = c.length, g = p(c, h); for (i = 0; i < h; ++i)s(g[i], this, e) } return !0 }, a.prototype.addListener = function (t, e) { return h(this, t, e, !1) }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function (t, e) { return h(this, t, e, !0) }, a.prototype.once = function (t, e) { return r(e), this.on(t, u(this, t, e)), this }, a.prototype.prependOnceListener = function (t, e) { return r(e), this.prependListener(t, u(this, t, e)), this }, a.prototype.removeListener = function (t, e) { var i, s, n, a, o; if (r(e), void 0 === (s = this._events)) return this; if (void 0 === (i = s[t])) return this; if (i === e || i.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete s[t], s.removeListener && this.emit("removeListener", t, i.listener || e)); else if ("function" != typeof i) { for (n = -1, a = i.length - 1; a >= 0; a--)if (i[a] === e || i[a].listener === e) { o = i[a].listener, n = a; break } if (n < 0) return this; 0 === n ? i.shift() : function (t, e) { for (; e + 1 < t.length; e++)t[e] = t[e + 1]; t.pop() }(i, n), 1 === i.length && (s[t] = i[0]), void 0 !== s.removeListener && this.emit("removeListener", t, o || e) } return this }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function (t) { var e, i, s; if (void 0 === (i = this._events)) return this; if (void 0 === i.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== i[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete i[t]), this; if (0 === arguments.length) { var n, a = Object.keys(i); for (s = 0; s < a.length; ++s)"removeListener" !== (n = a[s]) && this.removeAllListeners(n); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if ("function" == typeof (e = i[t])) this.removeListener(t, e); else if (void 0 !== e) for (s = e.length - 1; s >= 0; s--)this.removeListener(t, e[s]); return this }, a.prototype.listeners = function (t) { return d(this, t, !0) }, a.prototype.rawListeners = function (t) { return d(this, t, !1) }, a.listenerCount = function (t, e) { return "function" == typeof t.listenerCount ? t.listenerCount(e) : l.call(t, e) }, a.prototype.listenerCount = l, a.prototype.eventNames = function () { return this._eventsCount > 0 ? e(this._events) : [] } } }, e = {}; function i(s) { var n = e[s]; if (void 0 !== n) return n.exports; var a = e[s] = { exports: {} }; return t[s](a, a.exports, i), a.exports } i.d = (t, e) => { for (var s in e) i.o(e, s) && !i.o(t, s) && Object.defineProperty(t, s, { enumerable: !0, get: e[s] }) }, i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }; var s = {}; return (() => { i.r(s), i.d(s, { APP_VERSION_CODE: () => Ht, APP_VERSION_NAME: () => Pt, BatchStrategy: () => B, CARRIER_NAME: () => Vt, DEVICE_LOCALE: () => Mt, DEVICE_MODEL: () => At, DEVICE_TYPE: () => Nt, DecisionApiConfig: () => et, DecisionMode: () => K, Event: () => ot, EventCategory: () => $, FLAGSHIP_CLIENT: () => Gt, FLAGSHIP_CONTEXT: () => $t, FLAGSHIP_VERSION: () => Bt, FLAGSHIP_VISITOR: () => Kt, Flag: () => Xt, FlagMetadata: () => Ut, Flagship: () => ue, FlagshipStatus: () => F, HitAbstract: () => at, HitType: () => G, INTERFACE_NAME: () => Ft, INTERNET_CONNECTION: () => xt, IP: () => Ot, Item: () => rt, LOCATION_CITY: () => St, LOCATION_COUNTRY: () => bt, LOCATION_LAT: () => Et, LOCATION_LONG: () => Rt, LOCATION_REGION: () => Tt, LogLevel: () => a, OS_NAME: () => Dt, OS_VERSION_CODE: () => wt, OS_VERSION_NAME: () => Lt, Page: () => ct, Screen: () => ht, Transaction: () => gt, Visitor: () => U, default: () => de }); var t = i(187); const e = {}, n = globalThis.fetch; var a; !function (t) { t[t.NONE = 0] = "NONE", t[t.EMERGENCY = 1] = "EMERGENCY", t[t.ALERT = 2] = "ALERT", t[t.CRITICAL = 3] = "CRITICAL", t[t.ERROR = 4] = "ERROR", t[t.WARNING = 5] = "WARNING", t[t.NOTICE = 6] = "NOTICE", t[t.INFO = 7] = "INFO", t[t.DEBUG = 8] = "DEBUG", t[t.ALL = 9] = "ALL" }(a || (a = {})); const o = { name: "TypeScript" }, r = 25e5, c = "https://decision.flagship.io/v2/", h = "https://staging-events.flagship.io/v1", g = "v3", u = "ready", d = "Key {0} must not be null. Default value is returned.", l = "{0} must be a {1}", p = "visitorId must not be null or empty", f = "Method {0} is deactivated while SDK status is: {1}.", y = "The hit has been added to the pool queue : {0}", m = "ADD HIT", v = "Batch hit has been sent : {0}", C = "Activate hit has been sent : {0}", I = "SEND BATCH", _ = "SEND ACTIVATE", k = "SEND HIT", M = "INITIALIZATION", N = "UPDATE CONTEXT", A = "GET MODIFICATION", S = "GET MODIFICATION INFO", T = "ACTIVE MODIFICATION", b = "ADD HIT", E = "CACHE HIT", R = "FLUSH HIT", O = "LOOKUP HIT", D = "APP", L = "x-api-key", w = "x-env-id", V = "Content-Type", x = "x-sdk-client", P = "x-sdk-version", H = "application/json"; var F, G, B, K, $; !function (t) { t[t.NOT_READY = 0] = "NOT_READY", t[t.NOT_INITIALIZED = 0] = "NOT_INITIALIZED", t[t.STARTING = 1] = "STARTING", t[t.POLLING = 2] = "POLLING", t[t.READY_PANIC_ON = 3] = "READY_PANIC_ON", t[t.READY = 4] = "READY" }(F || (F = {})), function (t) { t.PAGE_VIEW = "PAGEVIEW", t.PAGE = "PAGEVIEW", t.SCREEN_VIEW = "SCREENVIEW", t.SCREEN = "SCREENVIEW", t.TRANSACTION = "TRANSACTION", t.ITEM = "ITEM", t.EVENT = "EVENT", t.SEGMENT = "SEGMENT", t.CONSENT = "CONSENT", t.CAMPAIGN = "CAMPAIGN" }(G || (G = {})), function (t) { t[t.CONTINUOUS_CACHING = 0] = "CONTINUOUS_CACHING", t[t.PERIODIC_CACHING = 1] = "PERIODIC_CACHING" }(B || (B = {})); class U extends t.EventEmitter { visitorDelegate; constructor(t) { super(), this.visitorDelegate = t, this.visitorDelegate.on(u, (t => { this.emit(u, t) })) } getModificationsArray() { return this.visitorDelegate.getModificationsArray() } getFlagsDataArray() { return this.visitorDelegate.getFlagsDataArray() } get visitorId() { return this.visitorDelegate.visitorId } set visitorId(t) { this.visitorDelegate.visitorId = t } get anonymousId() { return this.visitorDelegate.anonymousId } get hasConsented() { return this.visitorDelegate.hasConsented } setConsent(t) { this.visitorDelegate.setConsent(t) } get config() { return this.visitorDelegate.config } get context() { return this.visitorDelegate.context } get flagsData() { return this.visitorDelegate.flagsData } get modifications() { return this.visitorDelegate.flagsData } updateContext(t) { this.visitorDelegate.updateContext(t) } clearContext() { this.visitorDelegate.clearContext() } getFlag(t, e) { return this.visitorDelegate.getFlag(t, e) } getModification(t) { return this.visitorDelegate.getModification(t) } getModificationSync(t) { return this.visitorDelegate.getModificationSync(t) } getModifications(t, e) { return this.visitorDelegate.getModifications(t, e) } getModificationsSync(t, e) { return this.visitorDelegate.getModificationsSync(t, e) } getModificationInfo(t) { return this.visitorDelegate.getModificationInfo(t) } getModificationInfoSync(t) { return this.visitorDelegate.getModificationInfoSync(t) } synchronizeModifications() { return this.visitorDelegate.synchronizeModifications() } fetchFlags() { return this.visitorDelegate.fetchFlags() } activateModification(t) { return this.visitorDelegate.activateModification(t) } activateModifications(t) { return this.visitorDelegate.activateModifications(t) } sendHit(t) { return this.visitorDelegate.sendHit(t) } sendHits(t) { return this.visitorDelegate.sendHits(t) } getAllModifications(t = !1) { return this.visitorDelegate.getAllModifications(t) } getModificationsForCampaign(t, e = !1) { return this.visitorDelegate.getModificationsForCampaign(t, e) } getAllFlagsData(t = !1) { return this.visitorDelegate.getAllFlagsData(t) } getFlatsDataForCampaign(t, e = !1) { return this.visitorDelegate.getFlatsDataForCampaign(t, e) } authenticate(t) { this.visitorDelegate.authenticate(t) } unauthenticate() { this.visitorDelegate.unauthenticate() } } function q(t, ...e) { let i = t; for (let t = 0; t < e.length; t++) { const s = e[t]; i = i.replace(new RegExp(`\\{${t}\\}`, "g"), s) } return i } function j(t, e, i) { t && t.logManager && "function" == typeof t.logManager.error && t.logLevel && !(t.logLevel < a.ERROR) && t.logManager.error(e, i) } function Q(t, e, i) { t && t.logManager && "function" == typeof t.logManager.info && t.logLevel && !(t.logLevel < a.INFO) && t.logManager.info(e, i) } function W(t, e, i) { t && t.logManager && "function" == typeof t.logManager.debug && t.logLevel && !(t.logLevel < a.DEBUG) && t.logManager.debug(e, i) } function J() { return "undefined" != typeof window && !("Deno" in window) } function Y(t, e) { return typeof t == typeof e && ("object" != typeof t || "object" != typeof e || Array.isArray(t) === Array.isArray(e)) } function z() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (t) { const e = 16 * Math.random() | 0; return ("x" === t ? e : 3 & e | 8).toString(16) })) } function Z(t, e) { return JSON.stringify({ errorMessage: t, data: e }) } class X { _batchIntervals; _batchLength; _batchStrategy; constructor(t) { this._batchIntervals = t?.batchIntervals || 10, this._batchLength = t?.batchLength || 20, this._batchStrategy = t?.batchStrategy || B.CONTINUOUS_CACHING } get batchIntervals() { return this._batchIntervals } set batchIntervals(t) { this._batchIntervals = t } get batchLength() { return this._batchLength } set batchLength(t) { this._batchLength = t } get batchStrategy() { return this._batchStrategy } } !function (t) { t.DECISION_API = "API", t.BUCKETING = "BUCKETING" }(K || (K = {})); class tt { _envId; _apiKey; _decisionMode; _timeout; _logLevel; _statusChangedCallback; _logManager; _fetchNow; _pollingInterval; _onBucketingFail; _onBucketingSuccess; _onBucketingUpdated; _enableClientCache; _initialBucketing; _decisionApiUrl; _activateDeduplicationTime; _hitDeduplicationTime; _visitorCacheImplementation; _hitCacheImplementation; _disableCache; _trackingMangerConfig; _isCloudFlareClient; get isCloudFlareClient() { return this._isCloudFlareClient } set isCloudFlareClient(t) { this._isCloudFlareClient = t } get trackingMangerConfig() { return this._trackingMangerConfig } constructor(t) { const { envId: e, apiKey: i, timeout: s, logLevel: n, logManager: o, statusChangedCallback: r, fetchNow: h, decisionMode: g, enableClientCache: u, initialBucketing: d, decisionApiUrl: l, activateDeduplicationTime: p, hitDeduplicationTime: f, visitorCacheImplementation: y, hitCacheImplementation: m, disableCache: v, language: C, trackingMangerConfig: I, isCloudFlareClient: _ } = t; this.setSdkLanguageName(C), o && (this.logManager = o), this._trackingMangerConfig = new X(_ ? { batchStrategy: 3 } : I || {}), this.isCloudFlareClient = _, this.decisionApiUrl = l || c, this._envId = e, this._apiKey = i, this.logLevel = n ?? a.ALL, this.timeout = s || 2, this.fetchNow = void 0 === h || h, this.enableClientCache = void 0 === u || u, this._decisionMode = g || K.DECISION_API, this._initialBucketing = d, this.activateDeduplicationTime = p ?? 2.5, this.hitDeduplicationTime = f ?? 2.5, this.disableCache = !!v, y && (this.visitorCacheImplementation = y), m && (this.hitCacheImplementation = m), this.statusChangedCallback = r } setSdkLanguageName(t) { switch (t) { case 1: o.name = "ReactJS"; break; case 2: o.name = "React-Native"; break; default: o.name = "undefined" != typeof window && "Deno" in window ? "Deno" : "Typescript" } } get initialBucketing() { return this._initialBucketing } set initialBucketing(t) { this._initialBucketing = t } get enableClientCache() { return this._enableClientCache } set enableClientCache(t) { this._enableClientCache = t } get onBucketingSuccess() { return this._onBucketingSuccess } set onBucketingSuccess(t) { this._onBucketingSuccess = t } get onBucketingFail() { return this._onBucketingFail } set onBucketingFail(t) { this._onBucketingFail = t } get onBucketingUpdated() { return this._onBucketingUpdated } set onBucketingUpdated(t) { this._onBucketingUpdated = t } set envId(t) { this._envId = t } get envId() { return this._envId } set apiKey(t) { this._apiKey = t } get apiKey() { return this._apiKey } get decisionMode() { return this._decisionMode } get timeout() { return this._timeout } set timeout(t) { this._timeout = t } get logLevel() { return this._logLevel } set logLevel(t) { this._logLevel = t } get fetchNow() { return this._fetchNow } set fetchNow(t) { this._fetchNow = t } get pollingInterval() { return this._pollingInterval } set pollingInterval(t) { this._pollingInterval = t } get activateDeduplicationTime() { return this._activateDeduplicationTime } set activateDeduplicationTime(t) { "number" == typeof t ? this._activateDeduplicationTime = t : j(this, q(l, "activateDeduplicationTime", "number"), "activateDeduplicationTime") } get hitDeduplicationTime() { return this._hitDeduplicationTime } set hitDeduplicationTime(t) { "number" == typeof t ? this._hitDeduplicationTime = t : j(this, q(l, "hitDeduplicationTime", "number"), "hitDeduplicationTime") } get visitorCacheImplementation() { return this._visitorCacheImplementation } set visitorCacheImplementation(t) { this._visitorCacheImplementation = t } get hitCacheImplementation() { return this._hitCacheImplementation } set hitCacheImplementation(t) { this._hitCacheImplementation = t } get disableCache() { return this._disableCache } set disableCache(t) { this._disableCache = t } get statusChangedCallback() { return this._statusChangedCallback } set statusChangedCallback(t) { "function" == typeof t ? this._statusChangedCallback = t : j(this, "statusChangedCallback must be a function", "statusChangedCallback") } get logManager() { return this._logManager } set logManager(t) { this._logManager = t } get decisionApiUrl() { return this._decisionApiUrl } set decisionApiUrl(t) { "string" == typeof t ? this._decisionApiUrl = t : j(this, q(l, "decisionApiUrl", "string"), "decisionApiUrl") } } class et extends tt { constructor(t) { super({ ...t, decisionMode: K.DECISION_API }) } } class it { _config; _decisionManager; _trackingManager; constructor(t, e, i) { this._config = t, this._decisionManager = e, this._trackingManager = i } get config() { return this._config } set config(t) { this._config = t } get decisionManager() { return this._decisionManager } set decisionManager(t) { this._decisionManager = t } get trackingManager() { return this._trackingManager } set trackingManager(t) { this._trackingManager = t } } class st { _config; _panic = !1; _httpClient; _statusChangedCallback; get config() { return this._config } set panic(t) { this.updateFlagshipStatus(t ? F.READY_PANIC_ON : F.READY), this._panic = t } statusChangedCallback(t) { this._statusChangedCallback = t } constructor(t, e) { this._config = e, this._httpClient = t } updateFlagshipStatus(t) { "function" == typeof this._statusChangedCallback && this._statusChangedCallback && this._statusChangedCallback(t) } getModifications(t) { const e = new Map; return t.forEach((t => { const i = t.variation.modifications.value; for (const s in i) { const n = i[s]; e.set(s, { key: s, campaignId: t.id, variationGroupId: t.variationGroupId, variationId: t.variation.id, isReference: t.variation.reference, campaignType: t.type, slug: t.slug, value: n }) } })), e } isPanic() { return this._panic } } class nt extends st { async getCampaignsAsync(t) { const e = { [L]: `${this.config.apiKey}`, [x]: o.name, [P]: g, [V]: H }, i = { visitorId: t.visitorId, anonymousId: t.anonymousId, trigger_hit: !1, context: t.context }; let s = `${this.config.decisionApiUrl || c}${this.config.envId}/campaigns?exposeAllKeys=true`; return t.hasConsented || (s += "&sendContextEvent=false"), this._httpClient.postAsync(s, { headers: e, timeout: this.config.timeout, body: i }).then((t => { this.panic = !!t.body.panic; let e = null; return t.body.campaigns && (e = t.body.campaigns), e })).catch((t => (j(this.config, t.message || t, "GET CAMPAIGNS"), null))) } } class at { _visitorId; _config; _type; _ds; _anonymousId; _userIp; _screenResolution; _locale; _sessionNumber; _key; _createdAt; get key() { return this._key } set key(t) { this._key = t } get sessionNumber() { return this._sessionNumber } set sessionNumber(t) { this._sessionNumber = t } get locale() { return this._locale } set locale(t) { this._locale = t } get screenResolution() { return this._screenResolution } set screenResolution(t) { this._screenResolution = t } get userIp() { return this._userIp } set userIp(t) { this._userIp = t } get anonymousId() { return this._anonymousId } set anonymousId(t) { this._anonymousId = t } get visitorId() { return this._visitorId } set visitorId(t) { this._visitorId = t } get ds() { return this._ds } set ds(t) { this._ds = t } get type() { return this._type } get config() { return this._config } set config(t) { this._config = t } get createdAt() { return this._createdAt } set createdAt(t) { this._createdAt = t } constructor(t) { const { type: e, userIp: i, screenResolution: s, locale: n, sessionNumber: a, visitorId: o, anonymousId: r } = t; this._type = e, i && (this.userIp = i), s && (this.screenResolution = s), n && (this.locale = n), a && (this.sessionNumber = a), this.visitorId = o, this._anonymousId = r || null, this.createdAt = Date.now() } isNotEmptyString(t, e) { return !(!t || "string" != typeof t) || (j(this.config, q(l, e, "string"), e), !1) } isNumeric(t, e) { return !(!t || "number" != typeof t) || (j(this.config, q(l, e, "number"), e), !1) } isInteger(t, e) { return !!Number.isInteger(t) || (j(this.config, q(l, e, "integer"), e), !1) } toApiKeys() { const t = { vid: this.visitorId, ds: this.ds, eid: `${this.config?.envId}`, t: this.type, qt: Date.now() - this._createdAt }; return this.userIp && (t.uip = this.userIp), this.screenResolution && (t.sr = this.screenResolution), this.locale && (t.ul = this.locale), this.sessionNumber && (t.sn = this.sessionNumber), this.visitorId && this.anonymousId ? (t.vid = this.anonymousId, t.cuid = this.visitorId) : (t.vid = this.anonymousId || this.visitorId, t.cuid = null), t } toObject() { return { key: this.key, visitorId: this.visitorId, ds: this.ds, type: this.type, userIp: this.userIp, screenResolution: this.screenResolution, locale: this.locale, sessionNumber: this.sessionNumber, anonymousId: this.anonymousId, createdAt: this.createdAt } } isReady(t = !0) { return !!(this.visitorId && this.ds && this.config && this.config.envId && this.type) } } !function (t) { t.ACTION_TRACKING = "Action Tracking", t.USER_ENGAGEMENT = "User Engagement" }($ || ($ = {})); class ot extends at { _category; _action; _label; _value; _custom; get category() { return this._category } set category(t) { Object.values($).includes(t) ? this._category = t : j(this.config, "The category value must be either EventCategory::ACTION_TRACKING or EventCategory::ACTION_TRACKING", "category") } get action() { return this._action } set action(t) { this.isNotEmptyString(t, "action") && (this._action = t) } get label() { return this._label } set label(t) { this.isNotEmptyString(t, "label") && (this._label = t) } get value() { return this._value } set value(t) { !Number.isInteger(t) || t < 0 ? j(this.config, "value must be an integer and be >= 0", "value") : this._value = t } constructor(t) { super({ type: G.EVENT, userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }); const { category: e, action: i, label: s, value: n } = t; this.category = e, this.action = i, s && (this.label = s), n && (this.value = n) } toApiKeys() { const t = super.toApiKeys(); return t.ec = this.category, t.ea = this.action, this.label && (t.el = this.label), this.value && (t.ev = this.value), t } toObject() { return { ...super.toObject(), category: this.category, action: this.action, label: this.label, value: this.value } } isReady(t = !0) { return !(t && !super.isReady() || !this.category || !this.action) } getErrorMessage() { return "event category and event action are required" } } class rt extends at { _transactionId; _productName; _productSku; _itemPrice; _itemQuantity; _itemCategory; get transactionId() { return this._transactionId } set transactionId(t) { this.isNotEmptyString(t, "transactionId") && (this._transactionId = t) } get productName() { return this._productName } set productName(t) { this.isNotEmptyString(t, "productName") && (this._productName = t) } get productSku() { return this._productSku } set productSku(t) { this.isNotEmptyString(t, "productSku") && (this._productSku = t) } get itemPrice() { return this._itemPrice } set itemPrice(t) { this.isNumeric(t, "itemPrice") && (this._itemPrice = t) } get itemQuantity() { return this._itemQuantity } set itemQuantity(t) { this.isInteger(t, "itemQuantity") && (this._itemQuantity = Math.trunc(t)) } get itemCategory() { return this._itemCategory } set itemCategory(t) { this.isNotEmptyString(t, "itemCategory") && (this._itemCategory = t) } constructor(t) { super({ type: G.ITEM, userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }); const { transactionId: e, productName: i, productSku: s, itemCategory: n, itemPrice: a, itemQuantity: o } = t; this.transactionId = e, this.productName = i, this.productSku = s, n && (this.itemCategory = n), a && (this.itemPrice = a), o && (this.itemQuantity = o) } isReady(t = !0) { return !(t && !super.isReady() || !this.transactionId || !this.productName || !this.productSku) } toApiKeys() { const t = super.toApiKeys(); return t.tid = this.transactionId, t.in = this.productName, t.ic = this.productSku, this.itemPrice && (t.ip = this.itemPrice), this.itemQuantity && (t.iq = this.itemQuantity), this.itemCategory && (t.iv = this.itemCategory), t } toObject() { return { ...super.toObject(), transactionId: this.transactionId, productName: this.productName, productSku: this.productSku, itemPrice: this.itemPrice, itemQuantity: this.itemQuantity, itemCategory: this.itemCategory } } getErrorMessage() { return "Transaction Id, Item name and item code are required" } } class ct extends at { _documentLocation; get documentLocation() { return this._documentLocation } set documentLocation(t) { this.isNotEmptyString(t, "documentLocation") && (this._documentLocation = t) } constructor(t) { super({ type: G.PAGE_VIEW, userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }), this.documentLocation = t.documentLocation } isReady(t = !0) { return !(t && !super.isReady() || !this.documentLocation) } toApiKeys() { const t = super.toApiKeys(); return t.dl = this.documentLocation, t } toObject() { return { ...super.toObject(), documentLocation: this.documentLocation } } getErrorMessage() { return "documentLocation url is required" } } class ht extends at { _documentLocation; get documentLocation() { return this._documentLocation } set documentLocation(t) { this.isNotEmptyString(t, "documentLocation") && (this._documentLocation = t) } constructor(t) { super({ type: G.SCREEN_VIEW, userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }), this.documentLocation = t.documentLocation } isReady(t = !0) { return !(t && !super.isReady() || !this.documentLocation) } toApiKeys() { const t = super.toApiKeys(); return t.dl = this.documentLocation, t } toObject() { return { ...super.toObject(), documentLocation: this.documentLocation } } getErrorMessage() { return "Screen name is required" } } class gt extends at { _transactionId; _affiliation; _taxes; _currency; _couponCode; _itemCount; _shippingMethod; _paymentMethod; _totalRevenue; _shippingCosts; get transactionId() { return this._transactionId } set transactionId(t) { this.isNotEmptyString(t, "transactionId") && (this._transactionId = t) } get affiliation() { return this._affiliation } set affiliation(t) { this.isNotEmptyString(t, "affiliation") && (this._affiliation = t) } get taxes() { return this._taxes } set taxes(t) { this.isNumeric(t, "taxes") && (this._taxes = t) } get currency() { return this._currency } set currency(t) { t && "string" == typeof t && 3 === t.length ? this._currency = t : j(this.config, q("{0} must be a string and have exactly 3 letters", "currency"), "currency") } get couponCode() { return this._couponCode } set couponCode(t) { this.isNotEmptyString(t, "couponCode") && (this._couponCode = t) } get itemCount() { return this._itemCount } set itemCount(t) { this.isInteger(t, "itemCount") && (this._itemCount = Math.trunc(t)) } get shippingMethod() { return this._shippingMethod } set shippingMethod(t) { this.isNotEmptyString(t, "shippingMethod") && (this._shippingMethod = t) } get paymentMethod() { return this._paymentMethod } set paymentMethod(t) { this.isNotEmptyString(t, "paymentMethod") && (this._paymentMethod = t) } get totalRevenue() { return this._totalRevenue } set totalRevenue(t) { this.isNumeric(t, "totalRevenue") && (this._totalRevenue = t) } get shippingCosts() { return this._shippingCosts } set shippingCosts(t) { this.isNumeric(t, "shippingCosts") && (this._shippingCosts = t) } constructor(t) { super({ type: G.TRANSACTION, userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }); const { transactionId: e, affiliation: i, taxes: s, currency: n, couponCode: a, itemCount: o, shippingMethod: r, paymentMethod: c, totalRevenue: h, shippingCosts: g } = t; this.transactionId = e, this.affiliation = i, s && (this.taxes = s), n && (this.currency = n), a && (this.couponCode = a), o && (this.itemCount = o), r && (this.shippingMethod = r), c && (this.paymentMethod = c), h && (this.totalRevenue = h), g && (this.shippingCosts = g) } isReady(t = !0) { return !(t && !super.isReady() || !this.transactionId || !this.affiliation) } toApiKeys() { const t = super.toApiKeys(); return t.tid = this.transactionId, t.ta = this.affiliation, this.taxes && (t.tt = this.taxes), this.currency && (t.tc = this.currency), this.couponCode && (t.tcc = this.couponCode), this.itemCount && (t.icn = this.itemCount), this.shippingMethod && (t.sm = this.shippingMethod), this.paymentMethod && (t.pm = this.paymentMethod), this.totalRevenue && (t.tr = this.totalRevenue), this.shippingCosts && (t.ts = this.shippingCosts), t } toObject() { return { ...super.toObject(), transactionId: this.transactionId, affiliation: this.affiliation, taxes: this.taxes, currency: this.currency, couponCode: this.couponCode, itemCount: this.itemCount, shippingMethod: this.shippingMethod, paymentMethod: this.paymentMethod, totalRevenue: this.totalRevenue, shippingCosts: this.shippingCosts } } getErrorMessage() { return "Transaction Id and Transaction affiliation are required" } } class ut extends at { _visitorConsent; constructor(t) { super({ type: G.CONSENT, userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }), this.visitorConsent = t.visitorConsent } get visitorConsent() { return this._visitorConsent } set visitorConsent(t) { this._visitorConsent = t } isReady(t = !0) { return !(t && !super.isReady()) } toApiKeys() { const t = super.toApiKeys(); return t.vc = this.visitorConsent, t } toObject() { return { ...super.toObject(), visitorConsent: this.visitorConsent } } getErrorMessage() { return "visitorConsent is required" } } class dt extends at { _variationGroupId; _campaignId; constructor(t) { super({ type: G.CAMPAIGN, userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }), this.variationGroupId = t.variationGroupId, this.campaignId = t.campaignId } get variationGroupId() { return this._variationGroupId } set variationGroupId(t) { this._variationGroupId = t } get campaignId() { return this._campaignId } set campaignId(t) { this._campaignId = t } isReady(t = !0) { return !(t && !super.isReady() || !this.variationGroupId || !this.campaignId) } toApiKeys() { const t = super.toApiKeys(); return t.vgid = this.variationGroupId, t.caid = this.campaignId, t } toObject() { return { ...super.toObject(), variationGroupId: this.variationGroupId, campaignId: this.campaignId } } getErrorMessage() { return "variationGroupId and campaignId are required" } } class lt extends at { _sl; get sl() { return this._sl } set sl(t) { this._sl = t } constructor(t) { super({ type: G.SEGMENT, userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }), this.sl = t.sl } isReady(t = !0) { return !(t && !super.isReady() || !this.sl) } toApiKeys() { const t = super.toApiKeys(), e = {}; return Object.entries(this.sl).forEach((([t, i]) => { e[t] = i.toString() })), t.sl = e, t } toObject() { return { ...super.toObject(), sl: this.sl } } getErrorMessage() { return "sl is required" } } class pt extends at { _hits; get hits() { return this._hits } set hits(t) { this._hits = t } constructor(t) { super({ ...t, visitorId: "", anonymousId: "", type: "BATCH" }), this.hits = t.hits } isReady() { return !!(super.isReady() && this.hits && this.hits.length > 0 && this.hits.every((t => t.isReady(!1)))) } toApiKeys() { const t = { ds: this.ds, eid: `${this.config?.envId}`, t: this.type, qt: Date.now() - this.createdAt }; return t.h = this.hits.map((t => { const e = t.toApiKeys(); return delete e.ds, e })), t } getErrorMessage() { return "Please check required fields" } } class ft { _config; _hitsPoolQueue; _httpClient; get config() { return this._config } constructor(t, e, i) { this._config = t, this._hitsPoolQueue = i, this._httpClient = e } async cacheHit(t) { try { const e = this.config.hitCacheImplementation; if (this.config.disableCache || !e || "function" != typeof e.cacheHit) return; const i = {}; t.forEach(((t, e) => { const s = { version: 1, data: { visitorId: t.visitorId, anonymousId: t.anonymousId, type: t.type, content: t.toObject(), time: Date.now() } }; i[e] = s })), await e.cacheHit(i), W(this.config, q("Hit data has been saved into database : {0}", JSON.stringify(i)), E) } catch (t) { j(this.config, t.message || t, E) } } async flushHits(t) { try { const e = this.config.hitCacheImplementation; if (this.config.disableCache || !e || "function" != typeof e.flushHits) return; await e.flushHits(t), W(this.config, q("The following hit keys have been flushed from database : {0}", JSON.stringify(t)), R) } catch (t) { j(this.config, t.message || t, R) } } } class yt extends ft { async addHit(t) { const e = `${t.visitorId}:${z()}`; t.key = e, await this.addHitWithKey(e, t), t.type !== G.CONSENT || t.visitorConsent || await this.notConsent(t.visitorId), W(this.config, q(y, JSON.stringify(t.toApiKeys())), m) } async notConsent(t) { const e = Array.from(this._hitsPoolQueue.keys()).filter((e => e.includes(t))), i = []; e.forEach((t => { this._hitsPoolQueue.get(t)?.type === G.CONSENT || (this._hitsPoolQueue.delete(t), i.push(t)) })), i.length && await this.flushHits(i) } async addHitWithKey(t, e) { this._hitsPoolQueue.set(t, e), await this.cacheHit((new Map).set(t, e)) } async sendActivate(t) { const e = [], i = `${c}activate`, s = { [L]: this.config.apiKey, [x]: o.name, [P]: g, [V]: H }; for (const n of t) { this._hitsPoolQueue.delete(n.key); const t = n.toApiKeys(); try { await this._httpClient.postAsync(i, { headers: s, body: t }), e.push(n.key), W(this.config, q(C, JSON.stringify(t)), _) } catch (e) { this.addHitWithKey(n.key, n), j(this.config, Z(e.message || e, { url: i, headers: s, body: t }), _) } } e.length && await this.flushHits(e) } async sendBatch() { const t = { [L]: this.config.apiKey, [w]: this.config.envId, [x]: o.name, [P]: g, [V]: H }, e = new pt({ hits: [] }); e.config = this.config; let i = 0, s = 0; const n = []; for (const [t, a] of this._hitsPoolQueue) if ("ACTIVATE" !== a.type) { if (s++, i = JSON.stringify(e).length, i > r || this.config.trackingMangerConfig?.batchLength && s > this.config.trackingMangerConfig.batchLength) break; e.hits.push(a) } else n.push(a); if (await this.sendActivate(n), e.hits.forEach((t => { this._hitsPoolQueue.delete(t.key) })), !e.hits.length) return; const a = e.toApiKeys(); try { await this._httpClient.postAsync(h, { headers: t, body: a }), W(this.config, q(v, JSON.stringify(a)), I), await this.flushHits(e.hits.map((t => t.key))) } catch (i) { e.hits.forEach((t => { this.addHitWithKey(t.key, t) })), j(this.config, Z(i.message || i, { url: h, headers: t, body: a }), I) } } } class mt extends ft { async addHit(t) { const e = `${t.visitorId}:${z()}`; t.key = e, this._hitsPoolQueue.set(e, t), t.type !== G.CONSENT || t.visitorConsent || await this.notConsent(t.visitorId), W(this.config, q(y, JSON.stringify(t.toApiKeys())), m) } async notConsent(t) { const e = Array.from(this._hitsPoolQueue.keys()).filter((e => e.includes(t))), i = []; e.forEach((t => { this._hitsPoolQueue.get(t)?.type === G.CONSENT || (this._hitsPoolQueue.delete(t), i.push(t)) })), await this.cacheHit(this._hitsPoolQueue) } async sendActivate(t) { const e = `${c}activate`, i = { [L]: this.config.apiKey, [x]: o.name, [P]: g, [V]: H }; for (const s of t) { this._hitsPoolQueue.delete(s.key); const t = s.toApiKeys(); try { await this._httpClient.postAsync(e, { headers: i, body: t }), W(this.config, q(C, JSON.stringify(t)), _) } catch (n) { this._hitsPoolQueue.set(s.key, s), j(this.config, Z(n.message || n, { url: e, headers: i, body: t }), _) } } } async sendBatch() { const t = { [L]: `${this.config.apiKey}`, [w]: `${this.config.envId}`, [x]: o.name, [P]: g, [V]: H }, e = new pt({ hits: [] }); e.config = this.config; let i = 0, s = 0; const n = []; for (const [t, a] of this._hitsPoolQueue) if ("ACTIVATE" !== a.type) { if (s++, i = JSON.stringify(e).length, i > r || this.config.trackingMangerConfig?.batchLength && s > this.config.trackingMangerConfig.batchLength) break; e.hits.push(a) } else n.push(a); if (await this.sendActivate(n), !e.hits.length) return void (n.length && await this.cacheHit(this._hitsPoolQueue)); e.hits.forEach((t => { this._hitsPoolQueue.delete(t.key) })); const a = e.toApiKeys(); try { await this._httpClient.postAsync(h, { headers: t, body: a }), W(this.config, q(v, JSON.stringify(a)), I) } catch (i) { e.hits.forEach((t => { this._hitsPoolQueue.set(t.key, t) })), j(this.config, Z(i.message || i, { url: h, headers: t, body: a }), I) } await this.cacheHit(this._hitsPoolQueue) } } class vt extends ft { cacheHitKeys; constructor(t, e, i) { super(t, e, i), this.cacheHitKeys = {} } async addHit(t) { const e = `${t.visitorId}:${z()}`; t.key = e, t.type !== G.CONSENT || t.visitorConsent || await this.notConsent(t.visitorId), await this.cacheHit((new Map).set(e, t)), "ACTIVATE" !== t.type ? await this.sendHit(t) : await this.sendActivateHit(t) } async sendHit(t) { const e = { [L]: `${this.config.apiKey}`, [w]: `${this.config.envId}`, [x]: o.name, [P]: g, [V]: H }, i = t.toApiKeys(); try { await this._httpClient.postAsync(h, { headers: e, body: i }), W(this.config, q("hit has been sent : {0}", JSON.stringify(i)), k), await this.flushHits([t.key]) } catch (s) { t.type !== G.CONSENT && (this.cacheHitKeys[t.key] = t.key), j(this.config, Z(s.message || s, { url: h, headers: e, body: i }), k) } } async sendActivateHit(t) { const e = `${c}activate`, i = { [L]: this.config.apiKey, [x]: o.name, [P]: g, [V]: H }, s = t.toApiKeys(); try { await this._httpClient.postAsync(e, { headers: i, body: s }), W(this.config, q(C, JSON.stringify(s)), _), await this.flushHits([t.key]) } catch (n) { this.cacheHitKeys[t.key] = t.key, j(this.config, Z(n.message || n, { url: e, headers: i, body: s }), _) } } async notConsent(t) { const e = Object.keys(this.cacheHitKeys), i = Array.from(this._hitsPoolQueue.keys()).filter((e => e.includes(t))), s = []; i.forEach((t => { this._hitsPoolQueue.get(t)?.type === G.CONSENT || (this._hitsPoolQueue.delete(t), s.push(t)) })); const n = [...e, ...s]; n.length && (await this.flushHits(n), this.cacheHitKeys = {}) } async sendActivate(t) { const e = [], i = `${c}activate`, s = { [L]: this.config.apiKey, [x]: o.name, [P]: g, [V]: H }; for (const n of t) { this._hitsPoolQueue.delete(n.key); const t = n.toApiKeys(); try { await this._httpClient.postAsync(i, { headers: s, body: t }), e.push(n.key), W(this.config, q(C, JSON.stringify(t)), _) } catch (e) { this._hitsPoolQueue.set(n.key, n), j(this.config, Z(e.message || e, { url: i, headers: s, body: t }), _) } } e.length && await this.flushHits(e) } async sendBatch() { const t = { [L]: `${this.config.apiKey}`, [w]: `${this.config.envId}`, [x]: o.name, [P]: g, [V]: H }, e = new pt({ hits: [] }); e.config = this.config; let i = 0, s = 0; const n = []; for (const [t, a] of this._hitsPoolQueue) if ("ACTIVATE" !== a.type) { if (s++, i = JSON.stringify(e).length, i > r || this.config.trackingMangerConfig?.batchLength && s > this.config.trackingMangerConfig.batchLength) break; e.hits.push(a) } else n.push(a); if (e.hits.forEach((t => { this._hitsPoolQueue.delete(t.key) })), await this.sendActivate(n), !e.hits.length) return; const a = e.toApiKeys(); try { await this._httpClient.postAsync(h, { headers: t, body: a }), W(this.config, q(v, JSON.stringify(a)), I), await this.flushHits(e.hits.map((t => t.key))) } catch (i) { e.hits.forEach((t => { this._hitsPoolQueue.set(t.key, t) })), j(this.config, Z(i.message || i, { url: h, headers: t, body: a }), I) } } } class Ct extends at { _variationGroupId; _variationId; constructor(t) { super({ type: "ACTIVATE", userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }), this.variationGroupId = t.variationGroupId, this.variationId = t.variationId } get variationGroupId() { return this._variationGroupId } set variationGroupId(t) { this._variationGroupId = t } get variationId() { return this._variationId } set variationId(t) { this._variationId = t } isReady(t = !0) { return !(t && !super.isReady() || !this.variationGroupId || !this.variationId) } toApiKeys() { const t = { vid: this.anonymousId || this.visitorId, vaid: this.variationId, caid: this.variationGroupId, cid: this.config.envId, aid: null }; return this.visitorId && this.anonymousId && (t.vid = this.visitorId, t.aid = this.anonymousId), t } toObject() { return { ...super.toObject(), variationGroupId: this.variationGroupId, variationId: this.variationId } } getErrorMessage() { return "variationGroupId and variationId are required" } } class It extends class { _httpClient; _config; _hitsPoolQueue; strategy; _intervalID; _isPooling = !1; constructor(t, e) { this._hitsPoolQueue = new Map, this._httpClient = t, this._config = e, this.lookupHits(), this.strategy = this.initStrategy() } initStrategy() { let t; switch (this.config.trackingMangerConfig?.batchStrategy) { case B.PERIODIC_CACHING: t = new mt(this.config, this.httpClient, this._hitsPoolQueue); break; case B.CONTINUOUS_CACHING: t = new yt(this.config, this.httpClient, this._hitsPoolQueue); break; default: t = new vt(this.config, this.httpClient, this._hitsPoolQueue) }return t } get httpClient() { return this._httpClient } get config() { return this._config } startBatchingLoop() { const t = 1e3 * (this.config.trackingMangerConfig?.batchIntervals ?? 10); Q(this.config, "Batching Loop have been started", "startBatchingLoop"), this._intervalID = setInterval((() => { this.batchingLoop() }), t) } stopBatchingLoop() { clearInterval(this._intervalID), this._isPooling = !1, Q(this.config, "Batching Loop have been stopped", "stopBatchingLoop") } async batchingLoop() { this._isPooling || (this._isPooling = !0, await this.strategy.sendBatch(), this._isPooling = !1) } checKLookupHitData(t) { return !(1 !== t?.version || !t?.data?.type || !t?.data?.content) || (j(this.config, "JSON DATA must fit the type HitCacheDTO", O), !1) } async lookupHits() { try { const t = this.config.hitCacheImplementation; if (this.config.disableCache || !t || "function" != typeof t.lookupHits) return; const e = await t.lookupHits(); if (!e || !Object.keys(e).length) return; W(this.config, q("Hits data has been loaded from database: {0}", JSON.stringify(e)), O); const i = t => (Date.now() - t) / 1e3 <= 144e5, s = []; Object.entries(e).forEach((([t, e]) => { if (!this.checKLookupHitData(e) || !i(e.data.time)) return void s.push(t); let n; switch (e.data.type) { case G.CAMPAIGN: n = new dt(e.data.content); break; case G.CONSENT: n = new ut(e.data.content); break; case G.EVENT: n = new ot(e.data.content); break; case G.ITEM: n = new rt(e.data.content); break; case G.PAGE: n = new ct(e.data.content); break; case G.SCREEN: n = new ht(e.data.content); break; case G.SEGMENT: n = new lt(e.data.content); break; case "ACTIVATE": n = new Ct(e.data.content); break; case G.TRANSACTION: n = new gt(e.data.content); break; default: return }n.key = t, n.createdAt = e.data.content.createdAt, n.config = this.config, this._hitsPoolQueue.set(t, n) })), s.length && await this.strategy.flushHits(s) } catch (t) { j(this.config, t.message || t, O) } } }{ async addHit(t) { await this.strategy.addHit(t) } } class _t { consoleError; consoleWarn; constructor(t = !1) { this.consoleError = t ? console.log : console.error, this.consoleWarn = t ? console.log : console.warn } emergency(t, e) { this.consoleError(this.formatOutput(a.EMERGENCY, t, e)) } alert(t, e) { this.consoleError(this.formatOutput(a.ALERT, t, e)) } critical(t, e) { this.consoleError(this.formatOutput(a.CRITICAL, t, e)) } error(t, e) { this.consoleError(this.formatOutput(a.ERROR, t, e)) } warning(t, e) { this.consoleWarn(this.formatOutput(a.WARNING, t, e)) } notice(t, e) { this.log(a.NOTICE, t, e) } info(t, e) { console.info(this.formatOutput(a.INFO, t, e)) } debug(t, e) { console.debug(this.formatOutput(a.DEBUG, t, e)) } log(t, e, i) { console.log(this.formatOutput(t, e, i)) } formatOutput(t, e, i) { const s = new Date, n = t => 1 === t.toString().length ? `0${t}` : t; return `[${n(s.getFullYear())}-${n(s.getMonth())}-${n(s.getDay())} ${n(s.getHours())}:${n(s.getMinutes())}] [Flagship SDK] [${a[t]}] [${i}] : ${e}` } } class kt extends tt { constructor(t) { super({ ...t, decisionMode: K.BUCKETING }), this.pollingInterval = t?.pollingInterval ?? 1, this.onBucketingFail = t?.onBucketingFail, this.onBucketingSuccess = t?.onBucketingSuccess, this.onBucketingUpdated = t?.onBucketingUpdated } } const Mt = "sdk_deviceLanguage", Nt = "sdk_deviceType", At = "sdk_deviceModel", St = "sdk_city", Tt = "sdk_region", bt = "sdk_country", Et = "sdk_lat", Rt = "sdk_long", Ot = "sdk_ip", Dt = "sdk_osName", Lt = "sdk_osVersionName", wt = "sdk_osVersionCode", Vt = "sdk_carrierName", xt = "sdk_internetConnection", Pt = "sdk_versionName", Ht = "sdk_versionCode", Ft = "sdk_interfaceName", Gt = "fs_client", Bt = "fs_version", Kt = "fs_users", $t = { [Mt]: "string", [Nt]: "string", [At]: "string", [St]: "string", [Tt]: "string", [bt]: "string", [Et]: "number", [Rt]: "number", [Ot]: "string", [Dt]: "string", [Lt]: "string", [wt]: "string", [Vt]: "string", [xt]: "string", [Pt]: "string", [Ht]: "string", [Ft]: "string", [Gt]: "string", [Bt]: "string", [Kt]: "string" }; class Ut { campaignId; variationGroupId; variationId; isReference; campaignType; slug; constructor(t) { const { campaignId: e, variationGroupId: i, variationId: s, isReference: n, campaignType: a, slug: o } = t; this.campaignId = e, this.variationGroupId = i, this.variationId = s, this.isReference = n, this.campaignType = a, this.slug = o } static Empty() { return new Ut({ campaignId: "", campaignType: "", variationId: "", variationGroupId: "", isReference: !1, slug: null }) } } const qt = "property type is required and must "; class jt extends class { visitor; get configManager() { return this.visitor.configManager } get trackingManager() { return this.configManager.trackingManager } get decisionManager() { return this.configManager.decisionManager } get config() { return this.visitor.config } constructor(t) { this.visitor = t } updateCampaigns(t) { try { this.visitor.campaigns = t, this.visitor.flagsData = this.decisionManager.getModifications(t) } catch (t) { j(this.config, t.message || t, "updateCampaigns") } } hasTrackingManager(t) { const e = this.trackingManager; return e || j(this.config, q("trackerManager must not be null."), t), !!e } setConsent(t) { const e = "setConsent"; if (this.visitor.hasConsented = t, t || this.flushVisitor(), !this.hasTrackingManager(e)) return; const i = new ut({ visitorConsent: t, visitorId: this.visitor.visitorId, anonymousId: this.visitor.anonymousId }); i.ds = D, i.config = this.config, this.trackingManager.addHit(i).catch((t => { j(this.config, t.message || t, e) })) } checKLookupVisitorDataV1(t) { if (!t || !t.data || !t.data.visitorId) return !1; const e = t.data.campaigns; return !e || !!Array.isArray(e) && (t.data.visitorId !== this.visitor.visitorId ? (Q(this.config, q("Visitor ID mismatch: {0} vs {1}", t.data.visitorId, this.visitor.visitorId), "lookupVisitor"), !1) : e.every((t => t.campaignId && t.type && t.variationGroupId && t.variationId))) } checKLookupVisitorData(t) { return 1 === t.version && this.checKLookupVisitorDataV1(t) } async lookupVisitor() { try { const t = this.config.visitorCacheImplementation; if (this.config.disableCache || !t || !t.lookupVisitor || "function" != typeof t.lookupVisitor) return; const e = await t.lookupVisitor(this.visitor.visitorId); if (!e) return; if (!this.checKLookupVisitorData(e)) throw new Error("JSON DATA must fit the type VisitorCacheDTO"); this.visitor.visitorCache = e } catch (t) { j(this.config, t.message || t, "lookupVisitor") } } async cacheVisitor() { try { const t = this.config.visitorCacheImplementation; if (this.config.disableCache || !t || "function" != typeof t.cacheVisitor) return; const e = {}, i = { version: 1, data: { visitorId: this.visitor.visitorId, anonymousId: this.visitor.anonymousId, consent: this.visitor.hasConsented, context: this.visitor.context, campaigns: this.visitor.campaigns.map((t => (e[t.variationGroupId] = t.variation.id, { campaignId: t.id, slug: t.slug, variationGroupId: t.variationGroupId, variationId: t.variation.id, isReference: t.variation.reference, type: t.variation.modifications.type, activated: !1, flags: t.variation.modifications.value }))) } }; i.data.assignmentsHistory = { ...this.visitor.visitorCache?.data?.assignmentsHistory, ...e }, await t.cacheVisitor(this.visitor.visitorId, i), this.visitor.visitorCache = i } catch (t) { j(this.config, t.message || t, "cacheVisitor") } } async flushVisitor() { try { const t = this.config.visitorCacheImplementation; if (this.config.disableCache || !t || "function" != typeof t.flushVisitor) return; await t.flushVisitor(this.visitor.visitorId) } catch (t) { j(this.config, t.message || t, "flushVisitor") } } }{ checkPredefinedContext(t, e) { const i = $t[t]; if (!i) return null; let s = !1; return "string" === i ? s = "string" == typeof e : "number" === i && (s = "number" == typeof e), s || j(this.config, q("Predefined Context {0} must be type of {1}", t, i), N), s } updateContextKeyValue(t, e) { const i = typeof e; if ("string" != typeof t || "" === t || "string" !== i && "number" !== i && "boolean" !== i) return void j(this.visitor.config, q("params {0} must be a non null String, and 'value' must be one of the following types , Number, Boolean", t), N); if (t.match(/^fs_/i)) return; const s = this.checkPredefinedContext(t, e); ("boolean" != typeof s || s) && (this.visitor.context[t] = e) } updateContext(t) { if (t) for (const e in t) { const i = t[e]; this.updateContextKeyValue(e, i) } else j(this.visitor.config, "Context must not to be null", N) } clearContext() { this.visitor.context = {} } checkAndGetModification(t, e) { const { key: i, defaultValue: s, activate: n } = t; if (!i || "string" != typeof i) return j(this.config, q(d, i), A), s; const a = this.visitor.flagsData.get(i); if (!a) return Q(this.config, q("No modification for key {0}. Default value is returned.", i), A), s; return "object" == typeof a.value && "object" == typeof s && Array.isArray(a.value) !== Array.isArray(s) || typeof a.value != typeof s ? ((() => { j(this.config, q("Modification for key {0} has a different type. Default value is returned.", i), A), a.value || !n && !e || this.activateModification(i) })(), s) : ((n || e) && this.activateModification(i), a.value) } async getModifications(t, e) { return this.getModificationsSync(t, e) } getModificationsSync(t, e) { const i = {}; return t.forEach((t => { i[t.key] = this.checkAndGetModification(t, e) })), i } async getModification(t) { return this.getModificationSync(t) } getModificationSync(t) { return this.checkAndGetModification(t) } async getModificationInfo(t) { return this.getModificationInfoSync(t) } getModificationInfoSync(t) { if (!t || "string" != typeof t) return j(this.visitor.config, q(d, t), S), null; return this.visitor.flagsData.get(t) || (j(this.visitor.config, q("No modification for key {0}.", t), S), null) } fetchVisitorCampaigns(t) { return Array.isArray(t?.visitorCache?.data.campaigns) ? (t.updateContext(t.visitorCache.data.context || {}), t.visitorCache.data.campaigns.map((t => ({ id: t.campaignId, variationGroupId: t.variationGroupId, slug: t.slug, variation: { id: t.variationId, reference: !!t.isReference, modifications: { type: t.type, value: t.flags } } })))) : null } async globalFetchFlags(t) { try { let t = await this.decisionManager.getCampaignsAsync(this.visitor); if (t || (t = this.fetchVisitorCampaigns(this.visitor)), !t) return; this.visitor.campaigns = t, this.visitor.flagsData = this.decisionManager.getModifications(this.visitor.campaigns), this.visitor.emit(u) } catch (e) { this.visitor.emit(u, e), j(this.config, e.message || e, t) } } async synchronizeModifications() { return this.globalFetchFlags("SYNCHRONIZED MODIFICATION") } async activateModification(t) { if (t && "string" == typeof t) return this.activate(t); j(this.config, q("Key {0} must not be null, no activate will be sent.", t), T) } async activateModifications(t) { t && Array.isArray(t) ? t.forEach((t => { "string" == typeof t ? this.activate(t) : this.activate(t.key) })) : j(this.config, q(d, t), T) } isDeDuplicated(t, e) { if (0 === e) return !1; const i = this.visitor.deDuplicationCache[t]; return !!(i && Date.now() - i <= 1e3 * e) || (this.visitor.deDuplicationCache[t] = Date.now(), this.visitor.clearDeDuplicationCache(e), !1) } async sendActivate(t, e = "ACTIVE MODIFICATION") { const i = new Ct({ variationGroupId: t.variationGroupId, variationId: t.variationId, visitorId: this.visitor.visitorId, anonymousId: this.visitor.anonymousId }), { createdAt: s, ...n } = i.toObject(); this.isDeDuplicated(JSON.stringify(n), this.config.hitDeduplicationTime) || await this.prepareAndSendHit(i, e) } async activate(t) { const e = this.visitor.flagsData.get(t); e ? this.hasTrackingManager(T) && await this.sendActivate(e) : j(this.visitor.config, q("No modification for key {0}, no activate will be sent.", t), T) } async sendHit(t) { this.hasTrackingManager(b) && await this.prepareAndSendHit(t) } async sendHits(t) { if (this.hasTrackingManager(b)) for (const e of t) await this.prepareAndSendHit(e) } getHitLegacy(t) { let e = null; const i = { type: { Screen: G.SCREEN_VIEW, ScreenView: G.SCREEN_VIEW, Transaction: G.TRANSACTION, Page: G.PAGE_VIEW, PageView: G.PAGE_VIEW, Item: G.ITEM, Event: G.EVENT }[t.type] }, s = { ...i, ...t.data }; switch (i.type?.toUpperCase()) { case G.EVENT: e = new ot(s); break; case G.ITEM: const i = t.data; e = new rt({ ...s, productName: i.name, productSku: i.code, transactionId: i.transactionId, itemCategory: i.category, itemPrice: i.price, itemQuantity: i.quantity }); break; case G.PAGE_VIEW: e = new ct(s); break; case G.SCREEN_VIEW: e = new ht(s); break; case G.TRANSACTION: e = new gt(t.data) }return e } getHit(t) { let e = null; switch (t.type.toUpperCase()) { case G.EVENT: e = new ot(t); break; case G.ITEM: e = new rt(t); break; case G.PAGE_VIEW: e = new ct(t); break; case G.SCREEN_VIEW: e = new ht(t); break; case G.TRANSACTION: e = new gt(t) }return e } async prepareAndSendHit(t, e = "ADD HIT") { let i; if (!t?.type) return void j(this.config, "Hit must not be null", e); if (t instanceof at) i = t; else if ("data" in t) { const s = t, n = this.getHitLegacy(s); if (!n) return void j(this.config, qt, e); i = n } else { const s = this.getHit(t); if (!s) return void j(this.config, qt, e); i = s } i.visitorId = this.visitor.visitorId, i.ds = D, i.config = this.config, i.anonymousId = this.visitor.anonymousId; const { createdAt: s, ...n } = i.toObject(); if (!this.isDeDuplicated(JSON.stringify(n), this.config.hitDeduplicationTime)) if (i.isReady()) try { await this.trackingManager.addHit(i) } catch (t) { j(this.config, t.message || t, e) } else j(this.config, i.getErrorMessage(), e) } async getAllModifications(t = !1) { return this.getAllFlagsData(t) } async getAllFlagsData(t) { return t && this.visitor.flagsData.forEach(((t, e) => { this.activateModification(e) })), { visitorId: this.visitor.visitorId, campaigns: this.visitor.campaigns } } async getModificationsForCampaign(t, e = !1) { return this.getFlatsDataForCampaign(t, e) } async getFlatsDataForCampaign(t, e) { return e && this.visitor.flagsData.forEach((e => { e.campaignId === t && this.userExposed({ key: e.key, flag: e, defaultValue: e.value }) })), { visitorId: this.visitor.visitorId, campaigns: this.visitor.campaigns.filter((e => e.id === t)) } } authenticate(t) { const e = "authenticate"; this.config.decisionMode !== K.BUCKETING ? t ? (this.visitor.anonymousId = this.visitor.visitorId, this.visitor.visitorId = t) : j(this.config, p, e) : this.logDeactivateOnBucketing(e) } unauthenticate() { const t = "unauthenticate"; this.config.decisionMode !== K.BUCKETING ? this.visitor.anonymousId ? (this.visitor.visitorId = this.visitor.anonymousId, this.visitor.anonymousId = null) : j(this.config, "Visitor is not authenticated yet", t) : this.logDeactivateOnBucketing(t) } async fetchFlags() { return this.globalFetchFlags("fetchFlags") } async userExposed(t) { const { key: e, flag: i, defaultValue: s } = t, n = "userExposed"; if (i) if (null == s || !i.value || Y(i.value, s)) { if (this.hasTrackingManager(n)) return this.sendActivate(i, n) } else Q(this.visitor.config, q("Flag for key {0} has a different type with defaultValue, no activate will be sent", e), n); else Q(this.visitor.config, q("No flag for key {0}, no activate will be sent", e), n) } getFlagValue(t) { const { key: e, defaultValue: i, flag: s, userExposed: n } = t, a = "getFlag value"; return s ? s.value ? null == i || Y(s.value, i) ? (n && this.userExposed({ key: e, flag: s, defaultValue: i }), s.value) : (Q(this.config, q("Flag for key {0} has a different type. Default value is returned.", e), a), i) : (n && this.userExposed({ key: e, flag: s, defaultValue: i }), i) : (Q(this.config, q("No Flag for key {0}. Default value is returned.", e), a), i) } getFlagMetadata(t) { const { metadata: e, hasSameType: i, key: s } = t; return i ? e : (Q(this.visitor.config, q("Flag for key {0} has a different type with defaultValue, an empty metadata object is returned", s), "flag.metadata"), Ut.Empty()) } logDeactivateOnBucketing(t) { j(this.config, q("Method {0} is deactivated on Bucketing mode.", t), t) } } class Qt extends jt { async synchronizeModifications() { this.log("synchronizeModifications") } getModificationSync(t) { return this.log("getModification"), t.defaultValue } getModificationsSync(t, e) { this.log("getModifications"); const i = {}; return t.forEach((t => { i[t.key] = t.defaultValue })), i } async lookupHits() { } async lookupVisitor() { } async cacheVisitor() { } getModificationInfoSync(t) { return this.log("getModificationInfo"), null } async activateModification(t) { this.log("activateModification") } async activateModifications(t) { this.log("activateModifications") } sendHit(t) { return this.log("sendHit"), Promise.resolve() } sendHits(t) { return this.log("sendHits"), Promise.resolve() } async fetchFlags() { this.log("fetchFlags") } getFlagValue(t) { return this.log("Flag.value"), t.defaultValue } async userExposed() { this.log("userExposed") } getFlagMetadata() { return this.log("flag.metadata"), Ut.Empty() } log(t) { j(this.config, q(f, t, F[F.NOT_INITIALIZED]), t) } } class Wt extends jt { setConsent(t) { this.visitor.hasConsented = t, j(this.config, q("Send consent hit is deactivated while SDK status is: {1}.", F[F.READY_PANIC_ON]), "setConsent") } updateContext(t) { this.log("updateContext") } clearContext() { this.log("clearContext") } getModificationSync(t) { return this.log("getModification"), t.defaultValue } async lookupHits() { } async lookupVisitor() { } async cacheVisitor() { } async cacheHit() { } fetchVisitorCampaigns() { return [] } getModificationsSync(t, e) { this.log("getModifications"); const i = {}; return t.forEach((t => { i[t.key] = t.defaultValue })), i } getModificationInfoSync(t) { return this.log("getModificationInfo"), null } async activateModification(t) { this.log("activateModification") } async activateModifications(t) { this.log("activateModifications") } sendHit(t) { return this.log("sendHit"), Promise.resolve() } sendHits(t) { return this.log("sendHits"), Promise.resolve() } getFlagValue(t) { return this.log("Flag.value"), t.defaultValue } async userExposed() { this.log("userExposed") } getFlagMetadata() { return this.log("flag.metadata"), Ut.Empty() } log(t) { j(this.config, q(f, t, F[F.READY_PANIC_ON]), t) } } class Jt extends jt { async activateModification(t) { this.log("activateModification") } async activateModifications(t) { this.log("activateModifications") } async lookupHits() { } async lookupVisitor() { } async cacheVisitor() { } async cacheHit() { } fetchVisitorCampaigns() { return [] } sendHit(t) { return this.log("sendHit"), Promise.resolve() } sendHits(t) { return this.log("sendHits"), Promise.resolve() } async userExposed() { this.log("userExposed") } log(t) { j(this.config, q("Method {0} is deactivated for visitor {1} : visitor did not consent.", t, this.visitor.visitorId), t) } } const Yt = "FS_CLIENT_VISITOR", zt = { saveVisitorProfile(t) { try { localStorage.setItem(Yt, JSON.stringify(t)) } catch (t) { } }, loadVisitorProfile() { let t = null; try { t = localStorage.getItem(Yt) } catch (t) { } return t ? JSON.parse(t) : null } }; class Zt extends t.EventEmitter { _visitorId; _context; _flags; _configManager; _campaigns; _hasConsented; _anonymousId; deDuplicationCache; _isCleaningDeDuplicationCache; visitorCache; constructor(t) { const { visitorId: e, configManager: i, context: s, isAuthenticated: n, hasConsented: a, initialModifications: o, initialFlagsData: r, initialCampaigns: c } = t; super(), this._isCleaningDeDuplicationCache = !1, this.deDuplicationCache = {}, this._context = {}, this._configManager = i; const h = this.config.enableClientCache ? zt.loadVisitorProfile() : null; this.visitorId = e || h?.visitorId || z(), this.campaigns = [], this._anonymousId = h?.anonymousId || null, !this._anonymousId && n && this.config.decisionMode === K.DECISION_API && (this._anonymousId = z()), this.setConsent(a ?? !0), this.updateContext(s), this.loadPredefinedContext(), this.updateCache(), this.setInitialFlags(r || o), this.setInitializeCampaigns(c, !!o) } clearDeDuplicationCache(t) { if (this._isCleaningDeDuplicationCache) return; this._isCleaningDeDuplicationCache = !0; const e = Object.entries(this.deDuplicationCache); for (const [i, s] of e) Date.now() - s > 1e3 * t && delete this.deDuplicationCache[i]; this._isCleaningDeDuplicationCache = !1 } getModificationsArray() { return Array.from(this._flags, (([t, e]) => e)) } getFlagsDataArray() { return Array.from(this._flags, (([t, e]) => e)) } setInitialFlags(t) { this._flags = new Map, t && (t instanceof Map || Array.isArray(t)) && t.forEach((t => { this._flags.set(t.key, t) })) } setInitializeCampaigns(t, e) { t && Array.isArray(t) && !e && this.getStrategy().updateCampaigns(t) } updateCache() { const t = { visitorId: this.visitorId, anonymousId: this.anonymousId }; zt.saveVisitorProfile(t) } loadPredefinedContext() { this.context.fs_client = o.name, this.context.fs_version = g, this.context.fs_users = this.visitorId } get visitorId() { return this._visitorId } set visitorId(t) { t && "string" == typeof t ? (this._visitorId = t, this.loadPredefinedContext(), this.visitorCache = void 0) : j(this.config, p, "VISITOR ID") } get hasConsented() { return this._hasConsented } set hasConsented(t) { this._hasConsented = t } setConsent(t) { this.hasConsented = t, this.getStrategy().setConsent(t) } get context() { return this._context } set context(t) { this._context = {}, this.updateContext(t) } get flagsData() { return this._flags } set flagsData(t) { this._flags = t } get modifications() { return this._flags } set modifications(t) { this._flags = t } get configManager() { return this._configManager } get config() { return this.configManager.config } get campaigns() { return this._campaigns } set campaigns(t) { this._campaigns = t } get anonymousId() { return this._anonymousId } set anonymousId(t) { this._anonymousId = t } getStrategy() { let t; return t = ue.getStatus() && ue.getStatus() !== F.NOT_INITIALIZED ? ue.getStatus() === F.READY_PANIC_ON ? new Wt(this) : this.hasConsented ? new jt(this) : new Jt(this) : new Qt(this), t } } class Xt { _visitor; _key; _defaultValue; constructor(t) { const { key: e, visitor: i, defaultValue: s } = t; this._key = e, this._visitor = i, this._defaultValue = s } exists() { const t = this._visitor.flagsData.get(this._key); return !!(t?.campaignId && t.variationId && t.variationGroupId) } get metadata() { const t = this._visitor.flagsData.get(this._key), e = new Ut({ campaignId: t?.campaignId || "", variationGroupId: t?.variationGroupId || "", variationId: t?.variationId || "", isReference: !!t?.isReference, campaignType: t?.campaignType || "", slug: t?.slug }); return t ? this._visitor.getFlagMetadata({ metadata: e, hasSameType: !t.value || Y(t.value, this._defaultValue), key: t.key }) : e } userExposed() { const t = this._visitor.flagsData.get(this._key); return this._visitor.userExposed({ key: this._key, flag: t, defaultValue: this._defaultValue }) } getValue(t = !0) { const e = this._visitor.flagsData.get(this._key); return this._visitor.getFlagValue({ key: this._key, defaultValue: this._defaultValue, flag: e, userExposed: t }) } } class te extends Zt { updateContext(t) { this.getStrategy().updateContext(t), this.loadPredefinedContext() } clearContext() { this.getStrategy().clearContext() } getFlag(t, e) { return new Xt({ key: t, visitor: this, defaultValue: e }) } getModification(t) { return this.getStrategy().getModification(t) } getModificationSync(t) { return this.getStrategy().getModificationSync(t) } getModifications(t, e) { return this.getStrategy().getModifications(t, e) } getModificationsSync(t, e) { return this.getStrategy().getModificationsSync(t, e) } getModificationInfo(t) { return this.getStrategy().getModificationInfo(t) } getModificationInfoSync(t) { return this.getStrategy().getModificationInfoSync(t) } async synchronizeModifications() { await this.getStrategy().lookupVisitor(), await this.getStrategy().synchronizeModifications(), await this.getStrategy().cacheVisitor() } activateModification(t) { return this.getStrategy().activateModification(t) } activateModifications(t) { return this.getStrategy().activateModifications(t) } sendHit(t) { return this.getStrategy().sendHit(t) } sendHits(t) { return this.getStrategy().sendHits(t) } getAllModifications(t = !1) { return this.getStrategy().getAllModifications(t) } getAllFlagsData(t = !1) { return this.getStrategy().getAllFlagsData(t) } getModificationsForCampaign(t, e = !1) { return this.getStrategy().getModificationsForCampaign(t, e) } getFlatsDataForCampaign(t, e = !1) { return this.getStrategy().getFlatsDataForCampaign(t, e) } authenticate(t) { this.getStrategy().authenticate(t), this.updateCache() } unauthenticate() { this.getStrategy().unauthenticate(), this.updateCache() } async fetchFlags() { await this.getStrategy().lookupVisitor(), await this.getStrategy().fetchFlags(), await this.getStrategy().cacheVisitor() } userExposed(t) { return this.getStrategy().userExposed(t) } getFlagValue(t) { return this.getStrategy().getFlagValue(t) } getFlagMetadata(t) { return this.getStrategy().getFlagMetadata(t) } } class ee extends st { _bucketingContent; _lastModified; _isPooling; _murmurHash; _isFirstPooling; _intervalID; constructor(t, e, i) { super(t, e), this._murmurHash = i, this._isFirstPooling = !0, e.initialBucketing && (this._bucketingContent = e.initialBucketing) } finishLoop(t) { if (200 === t.status && (this._bucketingContent = t.body), t.headers && t.headers["last-modified"]) { const e = t.headers["last-modified"]; this._lastModified !== e && this.config.onBucketingUpdated && this.config.onBucketingUpdated(new Date(e)), this._lastModified = e } this._isFirstPooling && (this._isFirstPooling = !1, this.updateFlagshipStatus(F.READY)), "function" == typeof this.config.onBucketingSuccess && this.config.onBucketingSuccess({ status: t.status, payload: this._bucketingContent }), this._isPooling = !1 } async startPolling() { const t = 1e3 * this.config.pollingInterval; Q(this.config, "Bucketing polling starts", "startPolling"), await this.polling(), 0 !== t && (this._intervalID = setInterval((() => { this.polling() }), t)) } async polling() { if (!this._isPooling) { this._isPooling = !0, this._isFirstPooling && this.updateFlagshipStatus(F.POLLING); try { const t = q("https://cdn.flagship.io/{0}/bucketing.json", this.config.envId), e = { [L]: `${this.config.apiKey}`, [x]: o.name, [P]: g, [V]: H }; this._lastModified && (e["if-modified-since"] = this._lastModified); const i = await this._httpClient.getAsync(t, { headers: e, timeout: this.config.timeout }); this.finishLoop(i) } catch (t) { this._isPooling = !1, j(this.config, t, "startPolling"), this._isFirstPooling && this.updateFlagshipStatus(F.NOT_INITIALIZED), "function" == typeof this.config.onBucketingFail && this.config.onBucketingFail(new Error(t)) } } } stopPolling() { clearInterval(this._intervalID), this._isPooling = !1, Q(this.config, "Bucketing polling stopped", "stopPolling") } async sendContext(t) { try { if (Object.keys(t.context).length <= 3) return; const e = new lt({ sl: t.context, visitorId: t.visitorId, anonymousId: t.anonymousId }); await t.sendHit(e) } catch (t) { j(this.config, t.message || t, "sendContext") } } async getCampaignsAsync(t) { if (!this._bucketingContent) return null; if (this._bucketingContent.panic) return this.panic = !0, []; if (this.panic = !1, !this._bucketingContent.campaigns) return null; this.sendContext(t); const e = []; return this._bucketingContent.campaigns.forEach((i => { const s = this.getVisitorCampaigns(i.variationGroups, i.id, i.type, t); s && (s.slug = i.slug, e.push(s)) })), e } getVisitorCampaigns(t, e, i, s) { for (const n of t) if (this.isMatchTargeting(n, s)) { const t = this.getVariation(n, s); return t ? { id: e, variation: t, variationGroupId: n.id, type: i } : null } return null } getVariation(t, e) { const i = this._murmurHash.murmurHash3Int32(t.id + e.visitorId) % 100; let s = 0; for (const n of t.variations) { const a = e.visitorCache?.data?.assignmentsHistory, o = a ? a[t.id] : null; if (o) { const e = t.variations.find((t => t.id === o)); if (!e) continue; return { id: e.id, modifications: e.modifications, reference: e.reference } } if (void 0 !== n.allocation && (s += n.allocation, i <= s)) return { id: n.id, modifications: n.modifications, reference: n.reference } } return null } isMatchTargeting(t, e) { return !!(t && t.targeting && t.targeting.targetingGroups) && t.targeting.targetingGroups.some((t => this.checkAndTargeting(t.targetings, e))) } isANDListOperator(t) { return ["NOT_EQUALS", "NOT_CONTAINS"].includes(t) } checkAndTargeting(t, e) { let i, s = !1; for (const { key: n, value: a, operator: o } of t) if ("fs_all_users" !== n) { if ("fs_users" === n) i = e.visitorId; else { if (!(n in e.context)) { s = !1; break } i = e.context[n] } if (s = this.testOperator(o, i, a), !s) break } else s = !0; return s } testListOperatorLoop(t, e, i, s) { let n = s; for (const a of i) if (n = this.testOperator(t, e, a), n !== s) break; return n } testListOperator(t, e, i) { return this.isANDListOperator(t) ? this.testListOperatorLoop(t, e, i, !0) : this.testListOperatorLoop(t, e, i, !1) } testOperator(t, e, i) { let s; if (Array.isArray(i)) return this.testListOperator(t, e, i); switch (t) { case "EQUALS": s = e === i; break; case "NOT_EQUALS": s = e !== i; break; case "CONTAINS": s = e.toString().includes(i.toString()); break; case "NOT_CONTAINS": s = !e.toString().includes(i.toString()); break; case "GREATER_THAN": s = e > i; break; case "LOWER_THAN": s = e < i; break; case "GREATER_THAN_OR_EQUALS": s = e >= i; break; case "LOWER_THAN_OR_EQUALS": s = e <= i; break; case "STARTS_WITH": s = e.toString().startsWith(i.toString()); break; case "ENDS_WITH": s = e.toString().endsWith(i.toString()); break; default: s = !1 }return s } } class ie { murmurHash3Int32(t, e = 0) { let i, s, n, a; const o = 3 & t.length, r = t.length - o; i = e; const c = 3432918353, h = 461845907; for (a = 0; a < r;)n = 255 & t.charCodeAt(a) | (255 & t.charCodeAt(++a)) << 8 | (255 & t.charCodeAt(++a)) << 16 | (255 & t.charCodeAt(++a)) << 24, ++a, n = (65535 & n) * c + (((n >>> 16) * c & 65535) << 16) & 4294967295, n = n << 15 | n >>> 17, n = (65535 & n) * h + (((n >>> 16) * h & 65535) << 16) & 4294967295, i ^= n, i = i << 13 | i >>> 19, s = 5 * (65535 & i) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295, i = 27492 + (65535 & s) + ((58964 + (s >>> 16) & 65535) << 16); switch (n = 0, o) { case 3: n ^= (255 & t.charCodeAt(a + 2)) << 16; case 2: n ^= (255 & t.charCodeAt(a + 1)) << 8; case 1: n ^= 255 & t.charCodeAt(a), n = (65535 & n) * c + (((n >>> 16) * c & 65535) << 16) & 4294967295, n = n << 15 | n >>> 17, n = (65535 & n) * h + (((n >>> 16) * h & 65535) << 16) & 4294967295, i ^= n }return i ^= t.length, i ^= i >>> 16, i = 2246822507 * (65535 & i) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i ^= i >>> 13, i = 3266489909 * (65535 & i) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, i ^= i >>> 16, i >>> 0 } } class se { async getResponse(t) { const e = "application/json" === t.headers.get("Content-Type"), i = await t.text(); let s; if (i && e && (s = JSON.parse(i)), t.status >= 400) throw new Error(i || t.statusText); const n = {}; return t.headers.forEach(((t, e) => { n[e] = t })), { status: t.status, body: s, headers: n } } getAsync(t, i) { const s = new AbortController, a = setTimeout((() => s.abort()), 1e3 * (i?.timeout ? i.timeout : 2)); return n(t, { ...e, method: "GET", headers: i?.headers, signal: s.signal, keepalive: !0 }).then(this.getResponse).catch((t => { throw t })).finally((() => { clearInterval(a) })) } postAsync(t, i) { const s = new AbortController, a = setTimeout((() => s.abort()), i.timeout ? 1e3 * i.timeout : 2e3); return n(t, { ...e, method: "POST", headers: i.headers, body: JSON.stringify(i.body), signal: s.signal, keepalive: !0 }).then(this.getResponse).catch((t => { throw t })).finally((() => { clearInterval(a) })) } } const ne = "FS_DEFAULT_HIT_CACHE"; class ae { cacheHit(t) { const e = localStorage.getItem(ne) || "{}", i = { ...JSON.parse(e), ...t }; return localStorage.setItem(ne, JSON.stringify(i)), Promise.resolve() } lookupHits() { const t = localStorage.getItem(ne) || "{}", e = JSON.parse(t); return Promise.resolve(e) } flushHits(t) { const e = localStorage.getItem(ne) || "{}", i = JSON.parse(e); return t.forEach((t => { delete i[t] })), localStorage.setItem(ne, JSON.stringify(i)), Promise.resolve() } } const oe = "FS_VISITOR_CACHE_"; class re { cacheVisitor(t, e) { return localStorage.setItem(oe + t, JSON.stringify(e)), Promise.resolve() } lookupVisitor(t) { const e = localStorage.getItem(oe + t); return Promise.resolve(e ? JSON.parse(e) : null) } flushVisitor(t) { return localStorage.removeItem(oe + t), Promise.resolve() } } const ce = "3.0.10"; var he; !function (t) { t.ACTION_TRACKING = "Action Tracking", t.USER_ENGAGEMENT = "User Engagement" }(he || (he = {})); class ge extends at { _category; _action; _logVersion; _logLevel; _accountId; _envId; _timestamp; _component; _subComponent; _message; _stackType; _stackName; _stackVersion; _stackOriginName; _stackOriginVersion; _sdkStatus; _sdkConfigMode; _sdkConfigCustomLogManager; _sdkConfigCustomCacheManager; _sdkConfigStatusListener; _sdkConfigTimeout; _sdkConfigPollingTime; _sdkConfigTrackingManagerConfigStrategy; _sdkConfigTrackingManagerConfigBatchIntervals; _sdkConfigTrackingManagerConfigBatchLength; _httpRequestUrl; _httpRequestMethod; _httpRequestHeaders; _httpRequestBody; _httpRequestDetails; _httpResponseUrl; _httpResponseMethod; _httpResponseHeaders; _httpResponseBody; _httpResponseDetails; _visitorStatus; _visitorInstanceType; _visitorContext; _visitorConsent; _visitorAssignmentHistory; _visitorFlags; _visitorIsAuthenticated; _flagKey; _flagValue; _flagDefault; _flagMetadataCampaignId; _flagMetadataVariationGroupId; _flagMetadataVariationId; _flagMetadataCampaignSlug; _flagMetadataCampaignType; get flagMetadataCampaignType() { return this._flagMetadataCampaignType } set flagMetadataCampaignType(t) { this._flagMetadataCampaignType = t } get flagMetadataCampaignSlug() { return this._flagMetadataCampaignSlug } set flagMetadataCampaignSlug(t) { this._flagMetadataCampaignSlug = t } get flagMetadataVariationId() { return this._flagMetadataVariationId } set flagMetadataVariationId(t) { this._flagMetadataVariationId = t } get flagMetadataVariationGroupId() { return this._flagMetadataVariationGroupId } set flagMetadataVariationGroupId(t) { this._flagMetadataVariationGroupId = t } get flagMetadataCampaignId() { return this._flagMetadataCampaignId } set flagMetadataCampaignId(t) { this._flagMetadataCampaignId = t } get flagDefault() { return this._flagDefault } set flagDefault(t) { this._flagDefault = t } get flagValue() { return this._flagValue } set flagValue(t) { this._flagValue = t } get flagKey() { return this._flagKey } set flagKey(t) { this._flagKey = t } get visitorIsAuthenticated() { return this._visitorIsAuthenticated } set visitorIsAuthenticated(t) { this._visitorIsAuthenticated = t } get visitorFlags() { return this._visitorFlags } set visitorFlags(t) { this._visitorFlags = t } get visitorAssignmentHistory() { return this._visitorAssignmentHistory } set visitorAssignmentHistory(t) { this._visitorAssignmentHistory = t } get visitorConsent() { return this._visitorConsent } set visitorConsent(t) { this._visitorConsent = t } get visitorContext() { return this._visitorContext } set visitorContext(t) { this._visitorContext = t } get visitorInstanceType() { return this._visitorInstanceType } set visitorInstanceType(t) { this._visitorInstanceType = t } get visitorStatus() { return this._visitorStatus } set visitorStatus(t) { this._visitorStatus = t } get httpResponseDetails() { return this._httpResponseDetails } set httpResponseDetails(t) { this._httpResponseDetails = t } get httpResponseBody() { return this._httpResponseBody } set httpResponseBody(t) { this._httpResponseBody = t } _httpResponseCode; get httpResponseCode() { return this._httpResponseCode } set httpResponseCode(t) { this._httpResponseCode = t } get httpResponseHeaders() { return this._httpResponseHeaders } set httpResponseHeaders(t) { this._httpResponseHeaders = t } get httpResponseMethod() { return this._httpResponseMethod } set httpResponseMethod(t) { this._httpResponseMethod = t } get httpResponseUrl() { return this._httpResponseUrl } set httpResponseUrl(t) { this._httpResponseUrl = t } get httpRequestDetails() { return this._httpRequestDetails } set httpRequestDetails(t) { this._httpRequestDetails = t } get httpRequestBody() { return this._httpRequestBody } set httpRequestBody(t) { this._httpRequestBody = t } get httpRequestHeaders() { return this._httpRequestHeaders } set httpRequestHeaders(t) { this._httpRequestHeaders = t } get httpRequestMethod() { return this._httpRequestMethod } set httpRequestMethod(t) { this._httpRequestMethod = t } get httpRequestUrl() { return this._httpRequestUrl } set httpRequestUrl(t) { this._httpRequestUrl = t } get sdkConfigTrackingManagerConfigBatchLength() { return this._sdkConfigTrackingManagerConfigBatchLength } set sdkConfigTrackingManagerConfigBatchLength(t) { this._sdkConfigTrackingManagerConfigBatchLength = t } get sdkConfigTrackingManagerConfigBatchIntervals() { return this._sdkConfigTrackingManagerConfigBatchIntervals } set sdkConfigTrackingManagerConfigBatchIntervals(t) { this._sdkConfigTrackingManagerConfigBatchIntervals = t } get sdkConfigTrackingManagerConfigStrategy() { return this._sdkConfigTrackingManagerConfigStrategy } set sdkConfigTrackingManagerConfigStrategy(t) { this._sdkConfigTrackingManagerConfigStrategy = t } get sdkConfigPollingTime() { return this._sdkConfigPollingTime } set sdkConfigPollingTime(t) { this._sdkConfigPollingTime = t } get sdkConfigTimeout() { return this._sdkConfigTimeout } set sdkConfigTimeout(t) { this._sdkConfigTimeout = t } get sdkConfigStatusListener() { return this._sdkConfigStatusListener } set sdkConfigStatusListener(t) { this._sdkConfigStatusListener = t } get sdkConfigCustomCacheManager() { return this._sdkConfigCustomCacheManager } set sdkConfigCustomCacheManager(t) { this._sdkConfigCustomCacheManager = t } get sdkConfigCustomLogManager() { return this._sdkConfigCustomLogManager } set sdkConfigCustomLogManager(t) { this._sdkConfigCustomLogManager = t } get sdkConfigMode() { return this._sdkConfigMode } set sdkConfigMode(t) { this._sdkConfigMode = t } get sdkStatus() { return this._sdkStatus } set sdkStatus(t) { this._sdkStatus = t } get stackOriginVersion() { return this._stackOriginVersion } set stackOriginVersion(t) { this._stackOriginVersion = t } get stackOriginName() { return this._stackOriginName } set stackOriginName(t) { this._stackOriginName = t } get stackVersion() { return this._stackVersion } set stackVersion(t) { this._stackVersion = t } get stackName() { return this._stackName } set stackName(t) { this._stackName = t } get stackType() { return this._stackType } set stackType(t) { this._stackType = t } get message() { return this._message } set message(t) { this._message = t } get subComponent() { return this._subComponent } set subComponent(t) { this._subComponent = t } get component() { return this._component } set component(t) { this._component = t } get timestamp() { return this._timestamp } set timestamp(t) { this._timestamp = t } get envId() { return this._envId } set envId(t) { this._envId = t } get accountId() { return this._accountId } set accountId(t) { this._accountId = t } get logLevel() { return this._logLevel } set logLevel(t) { this._logLevel = t } get logVersion() { return this._logVersion } set logVersion(t) { this._logVersion = t } get category() { return this._category } get action() { return this._action } set action(t) { this.isNotEmptyString(t, "action") && (this._action = t) } constructor(t) { super({ type: "MONITORING", userIp: t.userIp, screenResolution: t.screenResolution, locale: t.locale, sessionNumber: t.sessionNumber, visitorId: t.visitorId, anonymousId: t.anonymousId }); const { action: e, logVersion: i, logLevel: s, accountId: n, envId: a, timestamp: r, component: c, subComponent: h, message: g, stackType: u, stackName: d, stackVersion: l, stackOriginName: p, stackOriginVersion: f, sdkStatus: y, sdkConfigMode: m, sdkConfigCustomLogManager: v, sdkConfigCustomCacheManager: C, sdkConfigStatusListener: I, sdkConfigTimeout: _, sdkConfigPollingTime: k, sdkConfigTrackingManagerConfigStrategy: M, sdkConfigTrackingManagerConfigBatchIntervals: N, sdkConfigTrackingManagerConfigBatchLength: A, httpRequestUrl: S, httpRequestMethod: T, httpRequestHeaders: b, httpRequestBody: E, httpRequestDetails: R, httpResponseUrl: O, httpResponseMethod: L, httpResponseHeaders: w, httpResponseCode: V, httpResponseBody: x, httpResponseDetails: P, visitorStatus: H, visitorInstanceType: F, visitorContext: G, visitorConsent: B, visitorAssignmentHistory: K, visitorFlags: $, visitorIsAuthenticated: U, config: q, flagKey: j, flagValue: Q, flagDefault: W, flagMetadataCampaignId: J, flagMetadataVariationGroupId: Y, flagMetadataVariationId: z, flagMetadataCampaignSlug: Z, flagMetadataCampaignType: X } = t; this.config = q, this._category = "monitoring", this.action = e, this.logVersion = i || "1", this.logLevel = s, this.accountId = n, this.envId = a || q.envId, this.timestamp = r || new Date(Date.now()).toISOString(), this.component = c || `Flagship SDK ${o.name}`, this.subComponent = h, this.message = g, this.stackType = u || "SDK", this.stackName = d || o.name, this.stackVersion = l || ce, this.stackOriginName = p, this.stackOriginVersion = f, this.sdkStatus = y, this.sdkConfigMode = m, this.sdkConfigCustomLogManager = v, this.sdkConfigCustomCacheManager = C, this.sdkConfigStatusListener = I, this.sdkConfigTimeout = _, this.sdkConfigPollingTime = k, this.sdkConfigTrackingManagerConfigStrategy = M, this.sdkConfigTrackingManagerConfigBatchIntervals = N, this.sdkConfigTrackingManagerConfigBatchLength = A, this.httpRequestUrl = S, this.httpRequestMethod = T, this.httpRequestHeaders = b, this.httpRequestBody = E, this.httpRequestDetails = R, this.httpResponseUrl = O, this.httpResponseMethod = L, this.httpResponseHeaders = w, this.httpResponseCode = V, this.httpResponseBody = x, this.httpResponseDetails = P, this.visitorStatus = H, this.visitorInstanceType = F, this.visitorContext = G, this.visitorConsent = B, this.visitorAssignmentHistory = K, this.visitorFlags = $, this.visitorIsAuthenticated = U, this.flagKey = j, this.flagValue = Q, this.flagDefault = W, this.flagMetadataCampaignId = J, this.flagMetadataVariationGroupId = Y, this.flagMetadataVariationId = z, this.flagMetadataCampaignSlug = Z, this.flagMetadataCampaignType = X, this.ds = D } toApiKeys() { const t = super.toApiKeys(); t.ec = this.category, t.ea = this.action; const e = { 0: `logVersion, ${this.logVersion}`, 1: `LogLevel, ${a[this.logLevel]}`, 4: `timestamp, ${this.timestamp}`, 5: `component, ${this.component}`, 6: `subComponents, ${this.subComponent}`, 7: `message, ${this.message}`, 20: `stack.type, ${this.stackType} `, 21: `stack.name, ${this.stackName}`, 22: `stack.version, ${this.stackVersion}` }; return this.accountId && (e[2] = `accountId, ${this.accountId}`), this.envId && (e[3] = `envId, ${this.envId}`), this.stackOriginName && (e[23] = `stack.origin.name, ${this.stackOriginName}`), this.stackOriginVersion && (e[24] = `stack.origin.version, ${this.stackOriginVersion}`), this.sdkStatus && (e[30] = `sdk.status, ${this.sdkStatus}`), this.sdkConfigMode && (e[31] = `sdk.config.mode, ${this.sdkConfigMode}`), void 0 !== this.sdkConfigCustomLogManager && (e[32] = `sdk.config.customLogManager, ${this.sdkConfigCustomLogManager}`), void 0 !== this.sdkConfigCustomCacheManager && (e[33] = `sdk.config.customCacheManager, ${this.sdkConfigCustomCacheManager}`), void 0 !== this.sdkConfigStatusListener && (e[34] = `sdk.config.custom.StatusListener, ${this.sdkConfigStatusListener}`), void 0 !== this.sdkConfigTimeout && (e[35] = `sdk.config.timeout, ${this.sdkConfigTimeout}`), void 0 !== this.sdkConfigPollingTime && (e[36] = `sdk.config.pollingTime, ${this.sdkConfigPollingTime}`), this.sdkConfigTrackingManagerConfigStrategy && (e[37] = `sdk.config.trackingManager.config.strategy, ${this.sdkConfigTrackingManagerConfigStrategy}`), void 0 !== this.sdkConfigTrackingManagerConfigBatchIntervals && (e[38] = `sdk.config.trackingManager.config.batchIntervals, ${this.sdkConfigTrackingManagerConfigBatchIntervals}`), void 0 !== this.sdkConfigTrackingManagerConfigBatchLength && (e[39] = `sdk.config.trackingManager.config.batchLength, ${this.sdkConfigTrackingManagerConfigBatchLength}`), this.httpRequestUrl && (e[50] = `http.request.url, ${this.httpRequestUrl}`), this.httpRequestMethod && (e[51] = `http.request.method, ${this.httpRequestMethod}`), this.httpRequestHeaders && (e[52] = `http.request.headers, ${this.httpRequestHeaders}`), this.httpRequestBody && (e[53] = `http.request.body, ${this.httpRequestBody}`), this.httpRequestDetails && (e[54] = `http.request.details, ${this.httpRequestDetails}`), this.httpResponseUrl && (e[60] = `http.response.url, ${this.httpResponseUrl}`), this.httpResponseMethod && (e[61] = `http.response.method, ${this.httpResponseMethod}`), this.httpResponseHeaders && (e[62] = `http.response.headers, ${this.httpResponseHeaders}`), this.httpResponseCode && (e[63] = `http.response.code, ${this.httpResponseCode}`), this.httpResponseBody && (e[64] = `http.response.body, ${this.httpResponseBody}`), this.httpResponseDetails && (e[65] = `http.response.details, ${this.httpResponseDetails}`), this.visitorStatus && (e[80] = `visitor.status, ${this.visitorStatus}`), this.visitorInstanceType && (e[81] = `visitor.instanceType, ${this.visitorInstanceType}`), this.visitorContext && (e[82] = `visitor.context, ${this.visitorContext}`), this.visitorConsent && (e[83] = `visitor.consent, ${this.visitorConsent}`), this.visitorAssignmentHistory && (e[84] = `visitor.assignmentsHistory, ${this.visitorAssignmentHistory}`), this.visitorFlags && (e[85] = `visitor.flags, ${this.visitorFlags}`), void 0 !== this.visitorIsAuthenticated && (e[86] = `visitor.isAuthenticated, ${this.visitorIsAuthenticated}`), this.flagKey && (e[100] = `flag.key, ${this.flagKey}`), this.flagValue && (e[101] = `flag.value, ${this.flagValue}`), this.flagDefault && (e[102] = `flag.default, ${this.flagDefault}`), this.flagMetadataCampaignId && (e[103] = `flag.metadata.campaignId, ${this.flagMetadataCampaignId}`), this.flagMetadataVariationGroupId && (e[104] = `flag.metadata.variationGroupId, ${this.flagMetadataVariationGroupId}`), this.flagMetadataVariationId && (e[105] = `flag.metadata.variationId, ${this.flagMetadataVariationId}`), this.flagMetadataCampaignSlug && (e[106] = `flag.metadata.campaignSlug, ${this.flagMetadataCampaignSlug}`), this.flagMetadataCampaignType && (e[107] = `flag.metadata.campaignType, ${this.flagMetadataCampaignType}`), t.cv = e, t } toObject() { return { ...super.toObject(), category: this.category, action: this.action, logVersion: this.logVersion, logLevel: this.logLevel, accountId: this.accountId, envId: this.envId, timestamp: this.timestamp, component: this.component, subComponent: this.subComponent, message: this.message, stackType: this.stackType, stackName: this.stackName, stackVersion: this.stackVersion, stackOriginName: this.stackOriginName, stackOriginVersion: this.stackOriginVersion, sdkStatus: this.sdkStatus, sdkConfigMode: this.sdkConfigMode, sdkConfigCustomLogManager: this.sdkConfigCustomLogManager, sdkConfigCustomCacheManager: this.sdkConfigCustomCacheManager, sdkConfigStatusListener: this.sdkConfigStatusListener, sdkConfigTimeout: this.sdkConfigTimeout, sdkConfigPollingTime: this.sdkConfigPollingTime, sdkConfigTrackingManagerConfigStrategy: this.sdkConfigTrackingManagerConfigStrategy, sdkConfigTrackingManagerConfigBatchIntervals: this.sdkConfigTrackingManagerConfigBatchIntervals, sdkConfigTrackingManagerConfigBatchLength: this.sdkConfigTrackingManagerConfigBatchLength, httpRequestUrl: this.httpRequestUrl, httpRequestMethod: this.httpRequestMethod, httpRequestHeaders: this.httpRequestHeaders, httpRequestBody: this.httpRequestBody, httpRequestDetails: this.httpRequestDetails, httpResponseUrl: this.httpResponseUrl, httpResponseMethod: this.httpResponseMethod, httpResponseHeaders: this.httpResponseHeaders, httpResponseCode: this.httpResponseCode, httpResponseBody: this.httpResponseBody, httpResponseDetails: this.httpResponseDetails, visitorStatus: this.visitorStatus, visitorInstanceType: this.visitorInstanceType, visitorContext: this.visitorContext, visitorConsent: this.visitorConsent, visitorAssignmentHistory: this.visitorAssignmentHistory, visitorFlags: this.visitorFlags, visitorIsAuthenticated: this.visitorIsAuthenticated, flagKey: this.flagKey, flagValue: this.flagValue, flagDefault: this.flagDefault, flagMetadataCampaignId: this.flagMetadataCampaignId, flagMetadataVariationGroupId: this.flagMetadataVariationGroupId, flagMetadataVariationId: this.flagMetadataVariationId, flagMetadataCampaignSlug: this.flagMetadataCampaignSlug, flagMetadataCampaignType: this.flagMetadataCampaignType } } isReady(t = !0) { return !(t && !super.isReady() || !this.category || !this.action) } getErrorMessage() { return "event category and event action are required" } } class ue { static _instance; _configManger; _config; _status; _visitorInstance; set configManager(t) { this._configManger = t } get configManager() { return this._configManger } constructor() { } static getInstance() { return this._instance || (this._instance = new this), this._instance } setStatus(t) { const e = this.getConfig().statusChangedCallback; if (this._status !== t && (this.getConfig().isCloudFlareClient || (t === F.READY ? this.configManager?.trackingManager?.startBatchingLoop() : this.configManager?.trackingManager?.stopBatchingLoop()), this.getConfig() && e)) return this._status = t, void e(t); this._status = t } static getStatus() { return this.getInstance()._status } getStatus() { return this._status } static getConfig() { return this.getInstance()._config } getConfig() { return this._config } getVisitor() { return this._visitorInstance } static getVisitor() { return this.getInstance().getVisitor() } buildConfig(t) { if (t instanceof tt) return t; let e; return e = t?.decisionMode === K.BUCKETING ? new kt(t) : new et(t), e } buildDecisionManager(t, e, i) { let s; const n = e => { t.setStatus(e) }; if (e.decisionMode === K.BUCKETING || e.isCloudFlareClient) { s = new ee(i, e, new ie); const t = s; s.statusChangedCallback(n), e.isCloudFlareClient || t.startPolling() } else s = new nt(i, e), s.statusChangedCallback(n); return s } static start(t, e, i) { const s = this.getInstance(), n = { useCustomLogManager: !!(i = s.buildConfig(i)).logManager, useCustomCacheManager: !!i.hitCacheImplementation || !!i.visitorCacheImplementation }; if (i.envId = t, i.apiKey = e, s._config = i, s.setStatus(F.STARTING), i.logManager || (i.logManager = new _t(i.isCloudFlareClient)), !t || !e) return s.setStatus(F.NOT_INITIALIZED), j(i, "Params 'envId' and 'apiKey' must not be null or empty.", M), s; !i.hitCacheImplementation && J() && (n.useCustomLogManager = !1, i.hitCacheImplementation = new ae), !i.visitorCacheImplementation && J() && (i.visitorCacheImplementation = new re); let o = s.configManager?.decisionManager; "object" == typeof o && o instanceof ee && !i.isCloudFlareClient && o.stopPolling(); const r = new se; o = s.buildDecisionManager(s, i, r); let c = s.configManager?.trackingManager; c || (c = new It(r, i)), s.configManager = new it(i, o, c), s._status === F.STARTING && s.setStatus(F.READY), Q(i, q("Flagship SDK (version: {0}) READY", ce), M); const h = new ge({ action: "SDK-INITIALIZATION", subComponent: "Flagship.start", logLevel: a.INFO, message: "Flagship initialized", sdkConfigCustomCacheManager: n.useCustomCacheManager, sdkConfigCustomLogManager: n.useCustomLogManager, sdkConfigMode: i.decisionMode, sdkConfigPollingTime: i.pollingInterval?.toString(), sdkConfigStatusListener: !!i.statusChangedCallback, sdkConfigTimeout: i.timeout?.toString(), sdkStatus: F[s.getStatus()], sdkConfigTrackingManagerConfigBatchIntervals: i.trackingMangerConfig?.batchIntervals?.toString(), sdkConfigTrackingManagerConfigBatchLength: i.trackingMangerConfig?.batchLength?.toString(), sdkConfigTrackingManagerConfigStrategy: B[i.trackingMangerConfig?.batchStrategy], visitorId: "0", anonymousId: "", config: i }); return c.addHit(h), s } newVisitor(t, e) { return ue.newVisitor(t, e) } static newVisitor(t, e) { let i, s, n, a, o = !1, r = !0, c = !J(); if (!this._instance?.configManager) return j(this.getConfig(), "Please start first the SDK in order to create a new Visitor", "NEW VISITOR"), null; "string" == typeof t || null === t ? (i = t || void 0, s = e || {}) : (i = t?.visitorId, s = t?.context || {}, o = !!t?.isAuthenticated, r = t?.hasConsented ?? !0, n = t?.initialFlagsData || t?.initialModifications, a = t?.initialCampaigns, c = t?.isNewInstance ?? c); const h = new te({ visitorId: i, context: s, isAuthenticated: o, hasConsented: r, configManager: this.getInstance().configManager, initialModifications: n, initialCampaigns: a, initialFlagsData: n }), g = new U(h); return this.getInstance()._visitorInstance = c ? void 0 : g, this.getConfig().fetchNow && !this.getConfig().isCloudFlareClient && g.fetchFlags(), g } } const de = ue })(), s })() }));
//# sourceMappingURL=index.jamstack.js.map